---
title: 정렬알고리즘 정리
date: 2018-10-13 21:25:54
tags:
    - Computer Science
    - Theory
    - Algorithm
categories:
    - 컴퓨터이론
    - 알고리즘
---

### 들어가며
***
이번 포스팅에서는 대표적인 정렬알고리즘 5가지와 대략적인 빅오표기법에 대해서 정리하려고 한다.
먼저, 그 5가지 정렬알고리즘은 다음과 같다.

***
1. 버블정렬(Bubble sort)
2. 선택정렬(Selection sort)
3. 삽입정렬(Insertion sort)
4. 병합정렬(Merge sort)
5. 퀵정렬(Quick sort)
***

그리고 이 알고리즘들의 성능은 `빅오표기법`으로 표현하므로, 빅오표기법에 대한 설명도 간단히 하고 넘어가려한다.

### Big O 표기법과 시간복잡도
***
알고리즘들의 성능을 판단하는 지표로는 `시간 복잡도(Time Complexity)`와 `공간 복잡도(Time Complexity)`가 있다. `시간 복잡도`는 알고리즘의 수행시간을 의미하는 지표이며, `공간 복잡도`는 알고리즘의 메모리 사용량을 의미한다.

보통 알고리즘에 대해서 공부하다보면 `이 알고리즘의 시간복잡도는 O n입니다` 혹은 `O의 n제곱입니다` 이런 식으로 이야기하거나 {% math %}O(n){% endmath %} 이런 식으로 작성되어있는 것을 볼 수 있었을 것이다.

이게 바로 `빅오(Big O) 표기법`이다. 말로 풀어보자면 {% math %}O(n){% endmath %}의 의미는 다음과 같다.

{% blockquote %}
이 함수는 n만큼의 데이터가 주어졌을 때, "최악"의 경우 n만큼의 리소스를 소모한다
{% endblockquote %}

이때 위에서 말한 `리소스`는 시간복잡도라면 `시간`이고 공간복잡도라면 `메모리공간`이 될 것이다.
하지만 보통 정렬알고리즘을 평가할때는 주로 `시간복잡도`에 집중하므로 여기서는 시간복잡도만 살펴보도록 하겠다.

먼저 시간복잡도에 대한 이해를 더 하기위해 `이진탐색`알고리즘의 시간복잡도를 살펴보자. 혹시 `이진탐색`을 잘모르는 사람은 술게임인 `업다운`을 생각해보자.
다들 잘 알겠지만 `업다운`은 다른 사람이 생각한 임의의 숫자를 맞춰야하는 게임이다. 이때, 가장 질문을 최소화할 수 있는 방법은 무엇일까? 바로 첫 질문에 중간 값인 `50`을 부르는 것이다. `50`을 부르고 상대방이 `업` 또는 `다운`을 하게되면 우리는 반대쪽에 있는 50개의 수는 버리고 나머지 50개만 다시 생각하면 되는 것이다.
근데 만약 상대방이 생각한 수가 `50`이라면?
바로 게임이 끝나고 누군가는 술을 먹게 되겠지...아 술땡기네...

어쨌든 이 게임에서 최악의 경우는 계속 `업&다운`을 반복하다가 {% math %}O({\log}N){% endmath %}번만에 끝나는 것이고 최선의 경우는 찾고자 하는 값을 첫 번째 추측으로 맞춰버린 상황. 즉, 시간복잡도는 {% math %}O(1){% endmath %}이 된다.

보는 바와 같이 최선의 결과와 최악의 결과 간 차이는 늘 있을 수 밖에 없기 때문에 보통 알고리즘을 평가할 때는 주로 **최악** 의 경우를 생각한다.
그리고 이런 **최악** 의 경우를 표현할 때 바로 `빅오 표기법`을 사용하는 것이다.

자주 나오는 것들은 보통 {% math %}O(1){% endmath %}, {% math %}O(n){% endmath %}, {% math %}O(n^2){% endmath %}, {% math %}O({\log}N){% endmath %} 정도가 있는데 알기 쉽게 2차원 그래프로 그려보면 다음과 같이 나타난다.

<center>{% asset_img 'big_o.png' %}</center>

`빅오 표기법`의 계산방법과 같은 더 자세한 내용은 다른 포스팅에서 다시 설명하도록 하겠다.

### 정렬알고리즘
***

<center>{% asset_img 'sorts.gif' %}</center>

`정렬알고리즘`은 컴퓨터공학에서 중요시되는 문제 중 하나로, 어떤 데이터셋이 주어졌을 때 이를 정해진 순서대로 나열하여 재배치하는 문제이다.
실제 개발을 하다보면 불규칙한 데이터들을 정렬 후 탐색해야하는 경우가 꽤나 많이 발생하게 되는데 이때 상황에 맞는 알고리즘을 사용하여 효과적으로 문제를 해결할 수 있느냐가 핵심이라고 볼 수 있다.

예를 들어 1부터 10까지 적혀있는 공이 불규칙하게 들어있는 주머니에서 공을 하나씩 꺼내어 작은 수부터 큰 수의 순서로 공을 나열한다고 생각해보자.
보통 이런 경우 사람도 어렵지 않게 쓱쓱 정렬해낸다. 하지만 컴퓨터가 주로 다루는 데이터는 `10,000`개일수도 `10,000,000`개일수도 있다. 그리고 데이터베이스 같은 경우는 이론상 무한 개의 데이터를 다룰 수 있어야 한다.

이때 데이터가 정렬되어 있지 않다면 순차적으로 하나씩 데이터를 봐가면서 탐색해야하지만, 데이터가 이미 정렬되어있다면 위에서 예시로 들었던 `이진탐색(Binary Search)`와 같은 강력한 알고리즘을 사용할 수도 있다.<small>(사실 이게 제일 큰 이유이다)</small>

자 그럼 대표적인 정렬알고리즘인 `버블정렬`, `선택정렬`, `삽입정렬`, `병합정렬`, `퀵정렬`을 한번 살펴보도록 하자.

#### 1. 버블정렬(Bubble sort)

<center>{% asset_img 'bubble_sort.gif' %}</center>

`버블정렬`은 거의 모든 상황에서 최악의 성능을 보여주지만, 이미 정렬된 자료에서는 1번만 순회하면 되기 때문에 최선의 성능을 보여주는 알고리즘이다. 이미 정렬되어 있는 데이터를 왜 정렬하냐는 의문이 들 수 있지만, 정렬알고리즘 자체는 데이터가 정렬되어 있는지 아닌지 모르고 작동하는 것이기 때문에 의미는 있다.

`버블정렬`은 다음과 같은 순서로 작동한다.

***

1. 0번째 원소와 1번째 원소를 비교 후 정렬
2. 1번째 원소와 2번째 원소를 비교 후 정렬
...
3. n-1번째 원소와 n번째 원소를 비교 후 정렬

***

한번 순회할 때마다 마지막 하나가 정렬되므로 원소들이 거품이 올라오는 것처럼 보여서 `버블정렬`이라고 부른다. 원리도 직관적이라서 구현하기 편하긴 하지만 꽤나 비효율적인 정렬 방식이다. 그래서 보통 처음 배울 때 한번 짜보고 나면 실무에서 쓰는 경우는 거의 못 봤다.<small>(물논 시간이 없다면 쓸 수도 있다...)</small>
구현코드는 다음과 같다.

```js
function bubbleSort (input) {
    const len = input.length;
    let tmp = null;
    for (let i = 0; i < len; i++) {
        for (let j = 0; j < len; j++) {
            if (input[j] > input[j + 1]) {
                // Swap
                tmp = input[j];
                input[j] = input[j + 1];
                input[j + 1] = tmp;
                tmp = null;
            }
        }
    }
    return input;
}
```
### 2. 선택정렬(Selection sort)

<center>{% asset_img 'selection_sort.gif' %}</center>
