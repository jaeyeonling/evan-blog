---
title: Vue Server Side Rendering
date: 2018-09-25 16:45:21
tags:
    - Web
    - Vue
    - NodeJS
    - Express
    - Server Side Rendering
    - SSR
categories:
    - Web
    - JavaScript
---

#### 들어가며
***
이번 포스팅에서는 {% post_link universal-ssr Universal Server Side Rendering %}에 이어서 VueJS의 공식 라이브러리인 `vue-server-renderer`와 `Express`를 사용하여 `SSR(Server Side Rendering)` 어플리케이션을 개발한 과정과 운영 환경에서 생겼던 문제, 그리고 그 문제를 어떻게 해결했는지 적어보려고 한다.
필자는 Frontend 개발자로 일하면서 Backend 프레임워크를 건드릴 일이 사실 거의 없었다. 그러나 필자의 현 직장에 SSR 서버를 필자가 도입하자고 주장하였고, 따라서 오너쉽도 필자에게 있었기 때문에 클라이언트 환경과 전혀 다른 서버의 작동방식과 여러 문제점에 대해서 상세하게 알고 있어야 할 필요가 있었다.
보통 Frontend 개발자는 클라이언트에서 작동하는 어플리케이션을 개발하기 때문에 서버에서 작동하는 어플리케이션에서 발생할 수 있는 <small>(조금만 생각해보면 당연한)</small>문제에 대해서 의외로 쉽게 놓치고 지나갈 수 있다고 생각한다.
그래서 두번 다시 이런 실수를 반복하지 않도록 문서로 정리를 하고 회고하려고 한다.

#### Vue Server Side Rendering의 구조
****
필자는 `Nuxt.js`를 사용하지 않고 보일러플레이트를 사용해서 구현했다. 처음에는 '그냥 Nuxt쓸걸...'이라고 후회하기도 했지만 그래도 덕분에 Universal SSR의 실행 과정을 더 깊게 알아볼 수 있는 좋은 기회였다고 생각한다.<small><del>(라고 삽질을 포장해본다)</del></small>
해당 포스팅에서는 필자가 작성했던 SSR 어플리케이션의 초기화 과정에 대해서 함수단위까지 자세하게 기재하려고 한다. 기본적으로는 이벤트 방식으로 실행되기 때문에 정확하게 이 순서가 딱딱 맞게 돌아가는 것은 아니고, 어떤 함수가 실행되서 어떤 역할을 하는지에 초점을 맞춰서 설명하려고 한다.
먼저 어플리케이션의 초기화 과정은 다음과 같다. 이후 각 과정에 대한 자세한 설명을 후술하도록 하겠다.

***
1. Request (Client -> Server)
2. app.get('*'): server.js
3. renderer.renderToStream(): server.js
4. load entry (server-entry.js)
5. createApp(): server-entry.js
6. router.onReady(): server-entry.js
7. stream.on(): server.js
8. Response (Server -> Client)

9. createApp(): client-entry.js
10. router.onReady(): client-entry.js
11. init(): client-entry.js
12. isValidRouteWithRole(): client-entry.js
13. app.$mount('#app')
***

Request와 Reponse를 제외한 `2~7`번 까지는 서버에서 일어나는 과정이고 `9~13`번 까지는 클라이언트에서 일어나는 과정이다. 여기서 한가지 짚고 넘어가야할 것은 서버와 클라이언트에서 같은 함수가 실행된다는 것이다.
`router.onReady`나 `createApp`같은 함수들이 그렇다.
Universal SSR은 기본적으로 `첫 요청만 SSR하자!`라는 개념이지만, 기본적으로 렌더링을 제외한 어플리케이션의 초기화 후 상태는 서버와 클라이언트가 공유할 수 없다. 진짜로 다른 컴퓨터니까.
그래서 기본적으로는 서버에서 한번 초기화, 클라이언트에서 한번 초기화 총 2번의 초기화 과정을 거쳐야한다. 하지만 서버에서 초기화를 하고 클라이언트에서 싹 다 처음부터 다시 하게 되면 비효율적이므로 몇가지 방법을 사용하여 최대한 효율적으로 렌더를 수행한다.
이제 하나하나씩 살펴보도록 하자.

#### Life Cycle
****
##### 1. Request
클라이언트에서 서버로 요청을 보낸다.

##### 2. app.get('*'): server.js
```js
const createRenderer = (bundle, template) => {
   return require('vue-server-renderer').createBundleRenderer(bundle, {
       template,
       runInNewContext: 'once',
   });
};
const bundle = require('./dist/vue-ssr-bundle.json');
const template = fs.readFileSync(resolve('./dist/index.html'), 'utf-8');
const renderer = createRenderer(bundle, template);
const app = require('express').express();

app.get('*', (req, res) => {
    if (!renderer) {
        return res.end('<pre>렌더링 중 입니다</pre>');
    }
    res.setHeader('Content-Type', 'text/html');
    
    const context = { url: req.url, cookie: req.cookies };
    if (!context.url) {
        errorLog('[ERR] context url is not exist!!', context);
    }
    
    // 렌더 스트림 진행
    const stream = renderer.renderToStream(context);
});
```

기본적으로는 `Express`의 라우터를 사용한다. 그러나 실질적인 라우팅은 `Vue`가 진행하기 때문에 `Express`에서는 `*` 와일드카드를 사용하여 모든 요청에 대한 콜백 함수를 실행하도록 한다.
이후 renderToStream 메소드가 실행되고나면 `Vue`가 호출되어 렌더링을 시작하게 된다.

예를 들어 서버에서는 클라이언트에 넘겨주고 싶은 상태(데이터)를 `Stringify`하여 어플리케이션 초기 렌더 시 HTML 템플릿에 주입해 `<script>window.__INITIAL_STATE__ = '{ ... }';</script>`와 같은 방식으로 선언하고 클라이언트는 이 변수를 불러와서 Vuex스토어에 그대로 덮어씌우는 형식으로 초기화 한다.

