---
title: Vue Server Side Rendering (서버편)
date: 2018-09-25 16:45:21
tags:
    - Web
    - Vue
    - NodeJS
    - Express
    - Server Side Rendering
    - SSR
categories:
    - Web
    - JavaScript
---

#### 들어가며
***
이번 포스팅에서는 {% post_link universal-ssr Universal Server Side Rendering %}에 이어서 VueJS의 공식 라이브러리인 `vue-server-renderer`와 `Express`를 사용하여 `SSR(Server Side Rendering)` 어플리케이션을 개발한 과정과 운영 환경에서 생겼던 문제, 그리고 그 문제를 어떻게 해결했는지 적어보려고 한다.
필자는 Frontend 개발자로 일하면서 Backend 프레임워크를 건드릴 일이 사실 거의 없었다. 그러나 필자의 현 직장에 SSR 서버를 필자가 도입하자고 주장하였고, 따라서 오너쉽도 필자에게 있었기 때문에 클라이언트 환경과 전혀 다른 서버의 작동방식과 여러 문제점에 대해서 상세하게 알고 있어야 할 필요가 있었다.
보통 Frontend 개발자는 클라이언트에서 작동하는 어플리케이션을 개발하기 때문에 서버에서 작동하는 어플리케이션에서 발생할 수 있는 <small>(조금만 생각해보면 당연한)</small>문제에 대해서 의외로 쉽게 놓치고 지나갈 수 있다고 생각한다.
그래서 두번 다시 이런 실수를 반복하지 않도록 문서로 정리를 하고 회고하려고 한다.

Universal SSR의 초기화 과정은 크게 서버 초기화와 클라이언트 초기화로 나누어지는데 한번에 작성하기엔 너무 양이 많이질 것 같아서 2개의 포스트로 나눠서 작성한다.
해당 포스트에서는 먼저 서버 쪽 초기화 과정을 설명하려고 한다.

#### Vue Server Side Rendering의 구조
***
필자는 `Nuxt.js`를 사용하지 않고 보일러플레이트를 사용해서 구현했다. 처음에는 '그냥 Nuxt쓸걸...'이라고 후회하기도 했지만 그래도 덕분에 Universal SSR의 실행 과정을 더 깊게 알아볼 수 있는 좋은 기회였다고 생각한다.<small><del>(라고 삽질을 포장해본다)</del></small>
해당 포스팅에서는 필자가 작성했던 SSR 어플리케이션의 초기화 과정에 대해서 함수단위까지 자세하게 기재하려고 한다. 기본적으로는 이벤트 방식으로 실행되기 때문에 정확하게 이 순서가 딱딱 맞게 돌아가는 것은 아니고, 어떤 함수가 실행되서 어떤 역할을 하는지에 초점을 맞춰서 설명하려고 한다.
먼저 어플리케이션의 초기화 과정은 다음과 같다. 이후 각 과정에 대한 자세한 설명을 후술하도록 하겠다.

***
1. Request (Client -> Server)
2. app.get('*'): server.js
3. renderer.renderToStream(): server.js
4. load entry (server-entry.js)
5. createApp(): server-entry.js
6. router.onReady(): server-entry.js
7. stream.on(): server.js
8. Response (Server -> Client)
9. createApp(): client-entry.js
10. router.onReady(): client-entry.js
11. init(): client-entry.js
12. isValidRouteWithRole(): client-entry.js
13. app.$mount('#app')
***

Request와 Reponse를 제외한 `2~7`번 까지는 서버에서 일어나는 과정이고 `9~13`번 까지는 클라이언트에서 일어나는 과정이다. 여기서 한가지 짚고 넘어가야할 것은 서버와 클라이언트에서 같은 함수가 실행된다는 것이다.
`router.onReady`나 `createApp`같은 함수들이 그렇다.
Universal SSR은 기본적으로 `첫 요청만 SSR하고 Vue컴포넌트는 서버랑 클라이언트에서 재사용가능하게 하자!`라는 개념이지만 문제가 하나 있는데, 서버와 클라이언트간 어플리케이션 상태는 공유될 수 없다는 것이다. 진짜로 다른 컴퓨터니까.
그래서 기본적으로는 서버에서 한번 초기화, 클라이언트에서 한번 초기화 총 2번의 초기화 과정을 거쳐야한다. 하지만 서버에서 초기화를 하고 클라이언트에서 싹 다 처음부터 다시 하게 되면 비효율적이므로 몇가지 방법을 사용하여 최대한 효율적으로 렌더를 수행한다.
이제 하나하나씩 살펴보도록 하자.

#### 1. Request
***
클라이언트에서 서버로 요청을 보낸다.

#### 2. app.get('*'): server.js
***
`server.js`에는 `Vue`코드는 없고 `NodeJS`로 작성된 `Express` 프레임워크의 코드가 작성되어있다.
```js
const fs = require('fs');
const express = require('express');

const createRenderer = (bundle, template) => {
   return require('vue-server-renderer').createBundleRenderer(bundle, {
       template,
       runInNewContext: 'once',
   });
};
const bundle = require('./dist/vue-ssr-bundle.json');
const template = fs.readFileSync(resolve('./dist/index.html'), 'utf-8');
const renderer = createRenderer(bundle, template);
const app = express();

app.get('*', (req, res) => {
    if (!renderer) {
        return res.end('<pre>렌더링 중 입니다 뿜뿜</pre>');
    }
    res.setHeader('Content-Type', 'text/html');
    
    const context = { url: req.url, cookie: req.cookies };
    if (!context.url) {
        errorLog('[ERR] context url is not exist!!', context);
    }
    
    // 렌더 스트림 진행
    const stream = renderer.renderToStream(context);
});
```

기본적으로는 `Express`의 라우터를 사용한다. 그러나 실질적인 라우팅은 `Vue`가 진행하기 때문에 `Express`에서는 `*` 와일드카드를 사용하여 모든 요청에 대한 콜백 함수를 실행하도록 한다.
밑에서 설명할 `vue-router`의 라우팅이랑 헷갈릴 수 있는데, 여기서 진행하는 라우팅은 `Express`의 라우팅이다. 방금 설명한 대로 실질적인 라우팅은 `Vue`에서 진행하게 되지만 Request를 `Express`에서 먼저 받아 처리하고 `Vue`로 넘어가는 순서이기 때문에 `Express`에서도 라우팅을 해줘야한다.
이후 `renderToStream` 메소드가 실행되고나면 `Vue`에서 진행되는 라우팅과 렌더링을 시작하게 된다.

#### 3. renderer.renderToStream(): server.js
***
이제 2번 항목 맨 끝 부분에서 선언한 Stream을 사용하여 HTML을 렌더한다.
위의 코드에서 Express의 라우팅 함수만 따로 가져와서 다시 살펴보자.  

```js
app.get('*', (req, res) => {
    // 2번 항목에 있던 코드는 생략합니다
    
    const stream = renderer.renderToStream(context);
    stream.on('data', () => {
        /* @desc
         * vue-meta 플러그인을 사용하면 컴포넌트에 선언되어있는 metaInfo 메소드에서 반환한 값을 받아올 수 있다.
         * https://github.com/declandewet/vue-meta 참고할 것
         */
        const {
            title, link, style, script, noscript, meta,
        } = context.meta.inject();
        context.head = `
            ${title.text()}
            ${meta.text()}
            ${link.text()}
            ${style.text()}
            ${script.text()}
            ${noscript.text()}
        `;
    })
    .on('error', err => {
        debug(`렌더 중 에러 발생`);
        // 에러 페이지를 보여주는 등의 에러 핸들링 로직이 위치한다.
    })
    .on('end', () => {
        debug(`렌더링 종료`);
    })
    .pipe(res);
});
```

`vue-ssr-renderer`는 `renderToString`과 `renderToStream`이라는 2가지 렌더 함수를 가지고 있다.
`renderToString`은 모든 렌더가 끝나면 렌더된 HTML을 string의 형태로 반환하고 그 이후 클라이언트로 HTML을 한번에 리턴해준다. 때문에 렌더 속도가 오래 걸리게 되면 유저는 빈 화면을 보고 있을 수 밖에 없다.
또한 `renderToString`은 데이터를 한번에 내려주기 때문에 파일로부터 HTML을 읽어올 때 내용을 전부 다 메모리에 올려야한다는 단점이 있다. HTML의 크기가 작으면 문제가 되지 않겠지만 파일의 크기가 커질 수록 매 렌더링 시 메모리 공간을 많이 잡아먹는다.

`renderToStream`은 한 이벤트가 끝날때마다 `ReadableStream`객체를 리턴한다. stream은 데이터를 일정한 chunk단위로 불러오고 `on`메소드를 사용한 이벤트 콜백 호출로 stream을 관리할 수 있는 nodeJS의 기능이다. data이벤트는 각 chunk가 `readable`상태가 될때마다 호출되며 모든 데이터를 불러왔다면 `end`이벤트가 호출된다.
이 stream에 관한 내용은 추후 다른 포스트에서 자세히 설명하도록 하겠다.

#### 4. load entry: server-entry.js
***
`renderToStream`함수가 실행되면 `vue-server-renderer`는 서버 쪽 엔트리 파일인 `server-entry.js`파일을 찾게된다. 이 파일에서는 `app.js`에 있는 팩토리 함수를 사용하여 app 객체를 생성하고 몇가지 초기화 과정을 거친 뒤 라우팅을 한다.

```js
import { createApp } from './app'; // 팩토리 함수 import
 
export default context => {
    return new Promise(async (resolve, reject) => {
        // 해당 프로미스에서 resolve되면 router.push가 호출된 후에도 stream이 계속 진행되고
        // 해당 프로미스에서 reject되면 stream의 error이벤트가 호출된다.
    });
};
```
이 파일의 코드를 설명하기 위해서는 상단에 import된 `createApp` 함수에서 리턴된 `app`, `store`, `router`가 뭔지 알고 있는 게 좋으므로, 자세히 살펴보기 전에 맨 위에서 import된 `createApp` 팩토리 함수를 먼저 살펴보자.

#### 5. createApp: app.js
***
createApp 함수는 `Vue` 인스턴스, `vue-router`의 `VueRouter` 인스턴스, `Vuex`의 `Store` 인스턴스를 리턴하는 팩토리 함수이다.
이후 이 팩토리 함수는 `server-entry`나 `client-entry`로 주입되어 초기화를 진행하게 된다.
```js
import Vue from 'vue';
import App from './App.vue';
import Store from './stores';
import { Router } from './router';

export function createApp() {
    const store = Store();
    const router = Router();
    const app = new Vue({ router, store, render: h => h(App) });
    return {
        app, router, store,
    }
}
```
일반적으로 클라이언트에서 `Vue`를 초기화하는 코드와 비슷하지만 다른 부분이 하나 있는데, `store`와 `router` 인스턴스를 팩토리 함수를 사용해서 생성한다는 점이다.
보통 `SPA` 어플리케이션에서는 이런 식으로 `Vue`인스턴스를 생성한다. 하지만 이 로직을 그대로 서버에서 사용하기엔 문제가 하나 있다.
```js
export default new Vue({
    el: '#app',
    components: { App },
    template: '<App/>',
    router: new VueRouter({ ... }),
    store: new Vuex.Store({ ... }),
});
```
문제는 `export default`로 `call by reference` 평가전략을 사용하는 자료형을 리턴하게 될 때 발생한다. `new Vue()`에서 호출하는 `Vue`는 결과적으로 함수이기 때문에 해당 코드는 최종적으로 `Vue` 인스턴스가 올라간 메모리 주소를 반환하게 되는데, 이 로직은 클라이언트에서는 딱히 문제가 없지만 서버에서는 문제가 발생할 수 있다.
클라이언트와 다르게 서버는 한번 올라가면 계속 돌아가는 **하나의** 프로그램이다. 현재 서버에 접속해있는 유저들이 `Store`의 상태를 공유하면 안되기 때문에 서버는 각 요청에 대해서 **새로운** `Store`와 `Vue` 인스턴스를 생성해야한다.
하지만 위의 코드에서 `export`하는 것은 `Vue`인스턴스의 메모리 주소이고 위 모듈이 `import` 될때 이 모듈은 처음 한번만 `Vue`인스턴스를 생성하고 이후는 참조해야하는 메모리 주소, 즉 **같은 인스턴스**를 반환하게 된다.
그렇기 떄문에 상태오염을 피하기 위해, 인스턴스가 아닌 팩토리 함수를 노출시키고 매번 새로운 인스턴스를 생성해 반환하는 방법으로 작성하여야 한다.

필자는 이 사실을 놓쳐서 유저들이 `Store`내부의 세션을 공유하게 되서 내 계정으로 로그인했지만 다른 사람 계정으로 로그인되버리는 버그를 생성한 적이 있다. 지금 생각해도 아찔한 순간이다.

{% blockquote Avoid Stateful Singletons - Vue SSR Guide %}
A Node.js server is a long-running process. When our code is required into the process, it will be evaluated once and stays in memory.
...
So, instead of directly creating an app instance, we should expose a factory function that can be repeatedly executed to create fresh app instances for each request.
{% endblockquote %}

심지어 이렇게 [공식 문서](https://ssr.vuejs.org/guide/structure.html#avoid-stateful-singletons)에도 버젓히 적혀있는 걸 안읽어서 엄청난 버그를 내고 말았다. 공식 문서를 반드시 읽읍시다! 두번세번 읽읍시다 ㅜㅜ

#### 6. router.onReady() : server-entry.js
***
자, 이제 `createApp`를 살펴보았으니 다시 `server-entry.js`로 돌아와서 해당 파일에 대한 설명을 계속 이어가겠다.
```js
import { createApp } from './app'; // 팩토리 함수 import
import { SESSION_KEY } from 'src/constants';
 
export default context => {
    return new Promise(async (resolve, reject) => {
        const { router, store } = createApp(); // 새로운 앱 생성
        const cookies = context.cookie;
        const clientSession = cookies[SESSION_KEY]; // 서버에서 쿠키에 심은 Session을 가져온다
        const next = () => {
            router.push(context.url);
        };
        
        if (clientSession) {
            store.dispatch(SET_SESSION, clientSession);
        }
 
        router.onReady(() => {
            // 라우팅 로직이 위치
        }, reject);
 
        next();
    });
};
```
이 파일의 메인 로직은 크게 2가지로 나누어 진다.
***
1. 15번째 라인. 쿠키에 세션이 생성되어있을 경우 Store에 인증상태를 저장하는 로직
2. 20번째 라인. 서버 측 라우팅 로직 및 예외처리
***
먼저 1번부터 살펴보자. 왜 굳이 인증상태를 Store에 담아야 할까? 먼저 이 서버는 렌더링만을 수행하는 렌더서버이기 때문에 세션의 유효성 검사는 외부에 있는 별도의 API서버와 통신을 해서 수행해야한다.
이런 인증상태정보는 서버에서도 필요하고 클라이언트에서도 필요한데 그럼 서버에서 한번 통신하고 클라이언트에서 한번 더 통신을 해야한다는 뜻이 된다. 하지만 이런 방식은 비효율적이기 때문에 보통 이런 유니버셜 SSR을 지원하는 프레임워크에서는 서버의 상태를 클라이언트로 반환해주는 방법으로 `widnow`객체에 서버의 상태를 직렬화해서 렌더 시 `<script>`태그 안에 선언해주는 방식을 사용한다.
`vue-server-renderer`에서는 클라이언트에 반환할 서버의 상태를 Vue의 [Flux아키텍처](https://haruair.github.io/flux/) 라이브러리인 [Vuex](https://vuex.vuejs.org/kr/)를 사용하여 선언한다.
그렇게 서버의 상태는 렌더 시 직렬화되어 `window.__INITIAL_STATE`라는 프로퍼티에 담기게 되고, 이후 클라이언트 초기화 시 해당 프로퍼티에 접근해 `replaceState`메소드를 사용해 Store를 업데이트하게 된다.

<br>
<center>
    {% asset_img 'initial_state.png' %}
    <sub>브라우저 콘솔에서 이렇게 확인해볼 수 있다</sub>
</center>
<br>

다음 2번 로직을 살펴보자. Universal SSR 어플리케이션은 맨 처음 사용자가 페이지를 열었을 때는 서버 쪽에서 라우팅을 진행하고 그 이후 사용자가 페이지를 이동할때는 클라이언트에서 라우팅을 진행하게된다.
즉 `server-entry.js` 내부의 라우팅 로직은 맨 처음 사용자가 어플리케이션을 초기 실행시킬 때 딱 한번 실행되는 로직이라는 의미이다. 필자는 서버에서는 이 라우터에 연결된 컴포넌트가 있는지에 대한 검사만 진행하고 클라이언트에 라우터 인증 관련 로직을 작성했기 때문에 서버 쪽 엔트리의 라우팅 로직은 간단하게 작성했다.
이 파일에서 `router`객체는 `createApp` 팩토리 함수에서 생성되어 반환된 `vue-router` 라이브러리 내 `VueRouter`클래스의 인스턴스이다.
필자는 이 클래스의 `getMatchedComponents` 메소드를 사용해서 현재 라우트가 유효한 라우트인지 검사하려고 한다.
`VueRouter`의 멤버변수와 메소드의 의미는 `vue-router`의 [공식 문서](https://router.vuejs.org/kr/api/#router-link)에도 나와있지만 가끔씩 라이브러리는 업데이트가 되었으나 공식 문서는 업데이트가 늦는 경우도 있으므로 개인적으로는 먼저 코드를 보는 것을 추천하는 편이다.

`node_modules/vue-router/types/router.d.ts` 파일을 살펴보면 `VueRouter` 클래스의 멤버 변수와 메소드를 확인할 수 있다.
```typescript
declare class VueRouter {
  constructor (options?: RouterOptions);

  app: Vue;
  mode: RouterMode;
  currentRoute: Route;

  beforeEach (guard: NavigationGuard): Function;
  beforeResolve (guard: NavigationGuard): Function;
  afterEach (hook: (to: Route, from: Route) => any): Function;
  push (location: RawLocation, onComplete?: Function, onAbort?: Function): void;
  replace (location: RawLocation, onComplete?: Function, onAbort?: Function): void;
  go (n: number): void;
  back (): void;
  forward (): void;
  getMatchedComponents (to?: RawLocation | Route): Component[];
  onReady (cb: Function, errorCb?: Function): void;
  onError (cb: Function): void;
  addRoutes (routes: RouteConfig[]): void;
  resolve (to: RawLocation, current?: Route, append?: boolean): {
    location: Location;
    route: Route;
    href: string;
    // backwards compat
    normalizedTo: Location;
    resolved: Route;
  };

  static install: PluginFunction<never>;
}
```
그럼 이제 `node_modules/vue-router/dist/vue-router.common.js`파일에서 `getMatchedComponent`이 어떻게 구현되어있는지 확인해보자.

```js
VueRouter.prototype.getMatchedComponents = function getMatchedComponents (to) {
  var route = to
    ? to.matched
      ? to
      : this.resolve(to).route
    : this.currentRoute;
  if (!route) {
    return []
  }
  return [].concat.apply([], route.matched.map(function (m) {
    return Object.keys(m.components).map(function (key) {
      return m.components[key]
    })
  }))
};
```
`VueRouter`클래스의 `getMatchedComponent`라는 메소드는 `to` 인자를 받으면 해당 라우트와 매치된 컴포넌트를 리턴하고, 인자가 주어지지 않는다면 현재 라우트에 매치된 컴포넌트를 리턴하도록 되어있다. 위에서 확인한 대로 `to`인자에는 `optional`을 의미하는 `?`가 붙어있으므로 필요한 경우가 아니면 굳이 인자를 넘겨줄 필요는 없을 것 같다. 이제 `router.onReady`이벤트훅 내부를 한번 작성해보자.

```js
router.onReady(() => {
    /**
    * @desc 현재 라우터에 연결되어 있는 컴포넌트가 없다면 404페이지를 렌더한다.
    */
    const matchedComponents = router.getMatchedComponents();
    if (!matchedComponents.length) {
        return reject({
            code: 404,
            msg: `${router.currentRoute.fullPath} is not found`,
        });
    }
    else {
        resolve(app);
    }
}, reject);
```

얼추 된 것 같다. 하지만 필자의 어플리케이션은 `asyncData`라는 프로퍼티를 사용하여 라우팅을 진행하기 전에 비동기로직을 기다릴 수 있도록 작성이 되어있다. Vue의 SSR라이브러리인 `Nuxt`에서도 비슷한 방식을 사용했던 것 같은데 이 부분은 잘 기억이 나지않는다.
어쨌든 현재 라우트에 매치된 컴포넌트리스트 중 `asyncData`를 가지고 있는 컴포넌트가 있다면 `Promise`를 사용해서 기다리도록 만들어주면 되는 간단한 로직이기 때문에 `Promise.all`을 사용하여 다음과 같이 작성하였다. 

그리고 모든 라우팅이 완료되었을 때 `context.state`에 `store`상태를 담아주면 `vue-server-renderer`가 알아서 `window.__INITIAL_STATE__`에 상태를 주입해준다.
```js
router.onReady(() => {
    /**
    * @desc 현재 라우터에 연결되어 있는 컴포넌트가 없다면 404페이지를 렌더한다.
    */
    const matchedComponents = router.getMatchedComponents();
    if (!matchedComponents.length) {
        return reject({
            code: 404,
            msg: `${router.currentRoute.fullPath} is not found`,
        });
    }
    // start: 추가된 부분
    Promise.all(matchedComponents.map(Component => {
        if (Component.asyncData) {
            return Component.asyncData({ route: router.currentRoute, store, });
        }
    })).then(() => {
        /** @desc
         * context에 state를 넘겨주고 렌더러에`template` 옵션을 사용하면 context.state를 직렬화하여 `window .__ INITIAL_STATE__`로 HTML에 주입해준다.
         */
        context.state = store.state;
        resolve(app);
    }).catch(reject);
    // end: 추가된 부분
}, reject);
```

#### 7. stream.on(), 8. Response
***
이렇게 `server-entry.js`에서 `Promise.resolve`가 호출되어 초기화가 끝나면 아까 선언해놓았던 `server.js`의 stream의 `end`이벤트가 실행된다. 이후 클라이언트로 렌더된 HTML을 Response에 담아서 내려주게 된다.
다음 포스팅에서는 HTML을 받고난 다음 클라이언트에서 초기화가 어떻게 이루어지는지 살펴보도록 하겠다.

이상으로 Vue Server Side Rendering (서버편) 포스팅을 마치겠습니다.
 



