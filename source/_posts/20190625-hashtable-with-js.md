---
title: JavaScript와 함께 해시테이블을 파헤쳐보자
date: 2019-06-25 00:22:36
tags:
  - HashTable
  - Data structure
  - JavaScript
  - Computer Science
categories:
  - Algorithm
thumbnail: /2019/06/25/hashtable-with-js/thumbnail.svg
toc: true
widgets:
  - 
    type: toc
    position: right
  - 
    type: category
    position: right
sidebar:
  right:
    sticky: true
---

이번 포스팅에서는 많이 사용되는 자료구조 중 하나인 `해시 테이블(Hash Table)`에 대해서 정리하려고 한다. 먼저 `해시 테이블`이 무엇인지, 왜 사용하는지 알아보고 우리의 친구 JavaScript로 한번 만들어보자!
<!-- more -->

## 해시 테이블(Hash Table)이 뭔가요?
해시 테이블은 어떤 특정 값을 받으면 그 값을 해시 함수에 통과시켜 나온 `인덱스(index)`에 저장하는 자료구조이다. 보통 배열을 사용해서 구현하는 경우가 많은 것 같다. 일단 `해시 함수`가 뭔지 `해시`가 뭔지 설명하기 전에 `해시 테이블`이라는 개념이 어디서부터 출발한 것인지 알아보자.

### 직접 주소 테이블(Direct Address Table)
`해시 테이블`의 아이디어는 `직접 주소 테이블`이라는 자료구조에서 부터 출발한다. `직접 주소 테이블`은 입력받은 `value`가 곧 `key`가 되는 데이터 매핑 방식이다. 코드로 보면 더 이해가 쉽다.

```js
class DirectAddressTable {
  constructor () {
    this.table = [];
  }

  setValue (value = -1) {
    if (value < 0) {
      return;
    }
    this.table[value] = value;
  }

  getValue (value = -1) {
    if (value < 0) {
      return null;
    }
    return this.table[value];
  }

  getTable () {
    return this.table;
  }
}

const myTable = new DirectAddressTable();
myTable.setValue(3);
myTable.setValue(10);
myTable.setValue(90);

console.log(myTable.getTable());
```

만약 데스크톱으로 이 포스팅을 보고 있다면 이 코드를 복붙한 후 브라우저 콘솔이나 NodeJS로 실행해보자.<small>(물론 IE에서는 안돌아간다)</small>
그러면 콘솔에 우리의 이쁜 테이블이 출력된다.

```text
[ <3 empty items>, 3, <6 empty items>, 10, <79 empty items>, 90 ]
```

우리가 `3`을 테이블에 넣으면 이 값은 배열의 `3`번 인덱스의 요소가 되고 `90`을 넣으면 `90`번 인덱스의 요소가 된다. 그야말로 초 심플하다.
이렇게 `직접 주소 테이블`을 사용할때는 들어오는 값이 뭔지 알면 이 값이 저장된 인덱스도 함께 알 수 있기 때문에 저장된 데이터에 바로 접근해서 값을 가져올 수 있다.

```js
myTable.getValue(3); // 3
```

찾고자 하는 값과 테이블의 인덱스가 동일하므로 테이블을 뒤적거릴 필요없이 값이 저장된 공간에 바로 접근해서 값을 올 수 있으므로 시간복잡도는 $O(1)$이다. 마찬가지로 테이블에 있는 값을 `삽입`, `수정`, `삭제`하는 행위도 값이 어디 있는지만 알고있으면 모두 한방에 해결할 수 있으므로 역시 $O(1)$의 시간복잡도로 해결할 수 있다.

보통 이런 단순한 자료구조에서 값을 `탐색`, `삽입`, `수정`, `삭제`하는 알고리즘이 시간을 잡아먹게 되는 이유는 대부분 비슷비슷하다.

***
1. 내가 찾고 싶은 값이 어디 있는지 모른다. 일단 효율적으로 뒤져보자.(`이진트리탐색` 같은 경우)
2. 내가 이 값을 삽입하거나 삭제하면 다른 값이 영향을 받는다.(`링크드 리스트` 같은 경우)
***

이렇게 `직접 주소 테이블`은 내가 보고 싶은 값이 어디 있는지 알고 있기 때문에 바로 접근해서 이후 작업을 수행할 수 있다는 점에서 굉장히 편리하다고 할 수 있다.

<center>
  {% asset_img 'fantastic.jpeg' %}
  <br>
</center>

하지만 `직접 주소 테이블`도 당연히 **단점**이 있다. 바로 `공간의 효율성`이 좋지 않다는 것이다.
방금 선언했던 `myTable`의 테이블 상태를 한번 보면 이해가 바로 된다. 이 테이블에는 `3`, `10`, `90`의 값을 넣었고 이 값들은 크기 차이가 꽤나 큰 편이다.

그 결과 우리의 `myTable`은 이렇게 듬성듬성한 구조로 데이터를 저장하게 된 것이다. 

```js
Array(100) [
 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 90]
```
<center>
  <sub>윌리를 찾아라 Array 버전. 값이 어디에 저장되었을까요?</sub>
  <br>
</center>

위에서도 볼 수 있듯이 저장된 데이터를 제외하고 `0`으로 채워진 나머지 공간은 `값은 없지만 메모리 공간은 할당되어 있는 상태`인 것이다. 즉, 사용하지 않는 아까운 공간이다. 즉 테이블에 넣고자 하는 데이터의 `값의 범위`보다 `값의 개수`가 작다면 공간적인 효율이 떨어지는 것이다.
이런 상황을 `적재율이 낮다`라고 표현하는데, 적재율은 `값의 개수/테이블의 크기`로 나타내게 된다. 필자가 방금 만든 이 테이블의 현재 적재율은 `3/90 = 0.3333...`으로 약 `3%` 정도이므로 높은 적재율은 아니라고 볼 수 있다.

이러다가 `1000`과 같이 큰 값이 테이블에 들어온다면 테이블의 크기는 `1001`이 되고 적재율은 약 `0.3%`가 된다. 즉, `직접 주소 테이블`이 큰 힘을 발휘할 수 있는 순간은 `1, 2, 3`과 같이 연속적인 값을 저장하거나 혹은 값이 범위 차이가 크지 않은 데이터라고 할 수 있다.

### 해시 함수로 직접 주소 테이블의 단점을 보완하자!
이렇게 `직접 주소 테이블`은 값에 접근하기는 편하지만 공간 효율이 좋지 않다는 단점이 있다. 그래서 이 단점을 보완한 게 바로 `해시 테이블`인 것이다.

`해시 테이블`은 `직접 주소 테이블`처럼 값을 바로 테이블의 인덱스로 사용하는 것이 아니라 `해시 함수(Hash Function)`이라는 것에 한번 통과시켜서 사용한다. `해시 함수`는 임의의 길이를 가지는 임의의 데이터를 고정된 길이의 데이터로 매핑하는 함수이다. 이때 이 함수가 뱉어내는 결과물을 `해시(Hash)`라고 부른다.

<center>
  {% asset_img 'hashbrown.jpg' %}
  <sub>해시(Hash)의 사전적 정의는 사실 "잘게 썬 요리" 같은 뉘앙스로 사용된다. 롯데리아에서 파는 해시브라운을 생각해보자.</sub>
  <br>
</center>

그럼 한번 이해를 돕기위해 간단한 `해시함수`를 만들어보겠다.

```js
function hashFunction (key = -1) {
  if (key < 0) {
    return null;
  }
  return key % 10;
}

function getRandomValue () {
  const max = 100000;
  const min = 1;
  return Math.floor(Math.random() * (max - min) + min);
}

console.log(hashFunction(getRandomValue())) // 8
console.log(hashFunction(getRandomValue())) // 2
console.log(hashFunction(getRandomValue())) // 3
console.log(hashFunction(getRandomValue())) // 3
```

자 끝났다. 물론 허접한 `해시 함수`이지만 그래도 `해싱`이라는 본연의 역할을 잘 수행할 수 있다. 필자의 허접한 `해시 함수`는 무조건 들어온 값을 `10`으로 나눈 후의 나머지를 반환하는 일을 할 뿐이지만 어떤 값이 들어오든 그 값의 `1`의 자리만 반환될 것이기 때문에 반환되는 값은 무조건 `0~9` 사이의 값이라는 것이 보장된다.

자 이제 이게 중요하다.

> 어떤 값이 해시 함수로 들어오든 무조건 0~9사이의 값이 반환된다!

`직접 주소 테이블`의 단점이 바로 `10000`이라는 값이 들어오게 되면 그 이외에 값이 아무것도 없어도 `10000`번 인덱스에 값이 저장하기 위해 `10000`의 크기를 가진 테이블을 생성해야하기 때문에 나머지 `9999`개의 버리는 공간이 생기는 것이다.
그러나 필자의 `해시 함수`를 사용하면 `100`이 들어오면 `0`을 반환할 것이고 `10001`이 들어오면 `1`을 반환 심지어 `8982174981274`가 들어와도 `4`를 반환한다.

즉, 고정된 테이블의 길이를 정해둘 수 있고 그 안에만 데이터를 저장할 수 있게 된 것이다. `해시 함수`의 이러한 성질을 이용해서 아주아주 간단한 해시테이블 예시를 한번 작성해보겠다. 필자는 `해시 테이블` 크기를 `5`로 설정하고 어떤 값이 들어와도 이 테이블 안에 저장될 수 있도록 `해시 함수`를 작성할 것이다.

```js
const myHashTableSize = 5;
const myHashTable = new Array(myHashTableSize);

function hashFunction (key = -1) {
  if (key < 0) {
    return null;
  }

  // 들어온 값을 테이블의 크기로 나눠주고 나머지를 반환하면 된다.
  return key % myHashTableSize;
}

myHashTable[hashFunction(1991)] = 1991;
myHashTable[hashFunction(1234)] = 1234;
myHashTable[hashFunction(5678)] = 5678;

console.log(myHashTable); // [empty, 1991, empty, 5678, 1234]
```

들어온 값들은 `1991`, `1234`, `5678`로, 해시 테이블의 사이즈인 `5`보다 훨씬 큰 값이지만 `해시 함수`를 거친 결과 `0~4` 사이의 값만 반환되기 때문에 필자의 해시 테이블 안에 값이 차곡차곡 저장될 수 있다.

이로써 `직접 주소 테이블`의 단점이었던 밑도 끝도 없이 낭비되는 공간을 줄일 수 있게 되었다!

## 해시의 충돌(Collision)
이렇게 해피 엔딩으로 끝나면 좋겠지만 `해시 테이블`의 단점도 있다. 그 단점은 바로 `해시`의 충돌이다. 필자의 `해시 함수`를 가지고와서 한번 충돌을 일으켜보자.

```js
hashFunction(1991) // 1
hashFunction(6) // 1
```

> 다른 값을 `해시 함수`에 넣었지만 같은 값이 튀어나오는 것이 바로 `충돌(Collision)`이다.

사실 상식적으로 생각해보면 `직접 주소 테이블`은 동적으로 테이블을 늘려나갔지만 `해시 테이블`은 고정적인 공간을 할당하고 값을 계속 우겨넣는 방식이다. 내가 테이블의 크기를 `100`으로 잡고 테이블에다가 `200`개의 데이터를 넣는다면 나머지 `100`개는 어디로 갔단 말인가?

하지만 애초에 `해시 테이블`은 담고자 하는 데이터의 양보다 테이블의 크기를 작게 하고 싶다는 의지에서 나온 자료구조이기 때문에 충돌을 해결할 수 있는 방법 또한 같이 고안되었다.

### 충돌 해결하기
#### 개방 주소법(Open Address)
`개방 주소법`은 해시 충돌이 발생하면 테이블 내의 새로운 주소를 `탐사(Probe)`하여 충돌된 데이터를 입력하는 방식이다. `해시 함수`를 통해서 얻은 인덱스가 아니라 다른 인덱스를 허용한다는 의미로 `개방 주소(Open Address)`라고 하는 것 같다.

`개방 주소법`은 어떤 방식으로 다른 주소를 탐사할 것이냐에 따라 4가지로 나누어 진다.

##### 1. 선형 탐사법(Linear Probing)
`선형 탐사법(Linear Probing)`은 말 그대로 선형으로 순차적으로 탐사하는 방법이다. 위에서 해시 충돌의 예로 들었던 `1991`과 `6`의 상황을 한번 예시로 알아보자.

{% raw %}
<br>
<ul class="hash-table-dummy">
  <li><dt>0</dt><dd></dd></li>
  <li><dt>1</dt><dd>1991</dd></li>
  <li><dt>2</dt><dd></dd></li>
  <li><dt>3</dt><dd></dd></li>
  <li><dt>4</dt><dd></dd></li>
</ul>
<br>
{% endraw %}

처음에 `1991`을 해시 테이블에 넣었을 때에는 테이블의 `1`번 인덱스에 위치했을 것이다. 그 이후 `6`을 `해시 함수`에 통과시키니까 `1991`과 같은 값인 `1`이 나왔다. 하지만 이미  `1`번 인덱스에는 `1991`이 자리잡고 있기 때문에  `6`은 더 이상 `해시 테이블`에 방을 잡을 수가 없게 되었다.

`선형 탐사법`은 이렇게 충돌이 났을 때 정해진 $n$ 칸만큼의 옆 방을 주는 방법이다. 만약에 $n = 1$이라면 `3`번 인덱스를, $n = 3$이라면 `5`번 인덱스에 `6`을 저장할 것이다.

{% raw %}
<br>
<ul class="hash-table-dummy">
  <li><dt>0</dt><dd></dd></li>
  <li><dt>1</dt><dd>1991</dd></li>
  <li><dt>2</dt><dd>6</dd></li>
  <li><dt>3</dt><dd></dd></li>
  <li><dt>4</dt><dd></dd></li>
</ul>
<br>
{% endraw %}

이런 식으로 충돌이 났을 때 순차적으로 정해진 만큼의 옆 방을 주는 것이 바로 `선형 탐사법`이다. 만약 여기서 또 충돌이 발생한다면 이번에는 그 값을 `3`번 인덱스에 저장할 것이다. `선형 탐사법`의 단점은 특정 해시 값의 주변이 모두 채워져있는 `Primary Clustering`문제에 취약하다는 것이다.

##### 2. 제곱 탐사법(Quadratic Probing)
`제곱 탐사법(Quadratic Probing)`은 `선형 탐사법`과 동일하지만 탐사하는 폭이 `고정폭`아닌 `제곱`으로 늘어난다는 것이 다르다.
첫번째 충돌이 발생했을 때는 $1^2$만큼, 두번째 충돌이 발생했을 때는 $2^2$, 세번째는 $3^2$과 같은 식으로 탐사하는 스텝이 빠르게 커진다.

<style>
ul.hash-table-dummy {
  width: 60%;
  margin: 0 auto;
  display: flex;
  border: 1px solid #ddd;
}
ul.hash-table-dummy > li {
  width: 20%;
  list-style: none;
  border-right: 1px solid #ddd;
  margin: 0;
  text-align: center;
}
ul.hash-table-dummy dt {
  border-bottom: 1px solid #ddd;
  background-color: #f0f0f0;
}
ul.hash-table-dummy dd {
  margin: 0;
}
</style>