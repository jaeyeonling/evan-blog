---
title: HTTP/3에 대해 알아보자(가제)
toc: true
widgets:
  - type: toc
    position: right
  - type: category
    position: right
sidebar:
  right:
    sticky: true
tags:
categories:
  - Programming
  - Network
thumbnail:
---

`HTTP/3`는 `HTTP(Hypertext Transfer Protocol)`의 세 번째 메이저 버전으로, 기존의 HTTP/1, HTTP/2와는 다르게 UDP 기반의 프로토콜인 `QUIC`를 사용하여 통신하는 프로토콜이다. HTTP/3와 기존 HTTP 들과 가장 큰 차이점이라면 TCP가 아닌 UDP 기반의 통신을 한다는 것이다.

<!-- more -->

필자는 최근에 다른 분들이 공유해주시는 포스팅을 보고 나서 HTTP/3가 나왔다는 것을 처음 알게 되었다. 그 포스팅은 [HTTP/3: the past, the present, and the future](https://blog.cloudflare.com/http3-the-past-present-and-future/)라는 포스팅이었는데, 솔직히 처음 딱 제목만 보고나서 이런 생각을 했었다.

> 아니, HTTP/2가 공개된지 4년 정도 밖에 안 지났는데 무슨 HTTP/3가 벌써 나와? 그냥 설계하고 있다는 거 아니야?

그런데 포스팅을 읽어 보니 이미 Google Chrome은 HTTP/3를 지원하는 있는 카나리 빌드도 배포되어있어서 실제로 사용까지 해볼 수 있는 단계에 도달했다는 사실을 알게 되어 놀랐다. HTTP/1에서 HTTP/2로 가는 데만 해도 대략 15년 정도의 시간이 걸렸는데, 고작 4년 만에 바로 사용해볼 수 있는 정도의 완성도인 다음 메이저 버전이 배포되었다는 것이다.

프로그래밍 언어나 프레임워크같은 친구들은 배포하는 쪽에서 업데이트를 쫙 해버리고 유저들이 업데이트를 하면 그만이지만, 프로토콜은 일종의 규약이기 때문에 소프트웨어 제조사 간 합을 맞추는 기간이 필요하므로 이렇게 단기간 안에 급격한 변화가 자주 발생하지 않을 것이라고 생각했다. 아무리 요즘 기술의 변화가 빠르다지만, HTTP는 나름 웹의 근간이 되는 프로토콜인데 꼴랑 4년 만에 이런 급격한 변화가 일어났다는 게 믿기 어려웠다.<small>(몇 달 전에 HTTP/2를 처음 도입해본 웹 개발자는 웁니다)</small>

<center>
  {% asset_img ce-http2.png 500 %}
  <small>W3Techs.com에서 조사한 2019년 8월 HTTP/2 사용률</small>
  <br>
</center>

그리고 또 한가지 놀랐던 점은 HTTP/3는 `TCP`가 아닌 `UDP`를 사용한다는 것이었다. 뭐 딱히 웹 프로토콜이 무조건 TCP만 사용해야 한다는 법이 있는 건 아니긴 하지만, 학교에서 배울 때도 그렇고 실무에서도 실제로 사용할 때도 그렇고 `HTTP는 TCP 위에서 정의된 프로토콜`이라는 사실이 너무 당연하게 인식되어 있었기 때문에 `UDP`를 사용한다는 점이 신기하기도 했고 `왜 멀쩡히 잘 돌아가는 TCP를 냅두고 UDP를 사용하는거지?`라는 의문도 들었다.

사실 HTTP/3는 정식으로 배포된 프로토콜이라기보다 아직 테스트를 거치고 있는 단계라고 보는 게 맞다. 하지만 위에서 이야기 했듯이 Google Chrome은 이미 HTTP/3를 지원하는 카나리 빌드를 배포한 상태이고, Mozila Firefox도 조만간 Nightly 버전에서 HTTP/3를 지원할 예정이며, cURL에서도 HTTP/3를 실험적 기능으로 제공하고 있는 만큼 가까운 미래 안에 HTTP/3가 메인 프로토콜이 될 가능성이 높은 것도 사실이다.

만약 Google Chrome에서 HTTP/3 프로토콜을 사용해보고 싶다면 터미널에서 `--enable-quic`과 `--quic-version=h3-23` 인자를 사용하여 실행하면 된다.

```bash
$ open -a Google\ Chrome --args --enable-quic --quic-version=h3-23
```

<center>
  {% asset_img http3-demo.png 500 %}
  <small>`http/2+quic/46`이라고 되어있는 녀석들이 HTTP/3 프로토콜을 사용한 연결이다</small>
  <br>
</center>

필자는 웹 개발자이기 때문에 HTTP가 메이저 업데이트 된다는 사실을 그냥 넘기기는 힘들었고, UDP를 사용한다는 것이 뭘 의미하는지도 궁금하기도 해서 결국 HTTP/3에 대한 조사를 하게 되었다. 그래서 이번 포스팅에서는 필자가 여기저기 쑤셔보면서 알아본 HTTP/3에 대한 내용을 정리해볼까 한다.

## HTTP/3에 대한 간단한 소개
사실 `HTTP/3`는 처음에는 `HTTP-over-QUIC`이라는 이름을 가지고 있었는데, `IETF(Internet Engineering Task Force)` 내 HTTP 작업 그룹과 QUIC 작업 그룹의 의장인 마크 노팅엄이 이 프로토콜의 이름을 HTTP/3로 변경할 것을 제안했고, 2018년 11월에 이 제안이 통과되어 HTTP-over-QUIC이라는 이름에서 HTTP/3으로 변경되게 되었다.

즉, HTTP/3는 `QUIC`이라는 프로토콜 위에서 돌아가는 HTTP인 것이다. QUIC는 `Quick UDP Internet Connection`의 약자로, 말 그대로 UDP를 사용하여 인터넷 연결을 하는 프로토콜이다. HTTP/3는 QUIC를 사용하고, QUIC는 UDP를 사용하기 때문에 결과적으로 `HTTP/3는 UDP를 사용한다` 라고 이야기 할 수 있는 것이다.

그렇다면 QUIC이 도대체 뭐길래 기존의 TCP보다 더 빠른 전송 속도를 가질 수 있다는 것일까? 그 이유를 알려면 먼저 TCP가 왜 느리다고 하는지, UDP를 사용함으로써 어떤 이득을 얻을 수 있는지 부터 알아야 한다.

## TCP가 왜 느린데?
필자는 학교에서 네트워크 강의를 들을 때 `TCP`와 `UDP`의 차이에 대한 내용을 처음 배웠었는데, 교수님이 이건 반드시 시험에 나온다길래 이런 표를 보면서 열심히 외웠던 기억이 난다.

| | TCP | UDP |
|---|---|---|
| 연결 방식 | 연결형 서비스 | 비연결형 서비스 |
| 패킷 교환 | 가상 회선 방식 | 데이터그램 방식 |
| 전송 순서 보장 | 보장함 | 보장하지 않음 |
| 신뢰성 | 높음 | 낮음 |
| 전송 속도 | 느림 | 빠름 |

위 표를 보면 대략 TCP는 `신뢰성이 높고 느리다`, UDP는 `신뢰성이 낮고 빠르다` 정도로 정리가 되는데, 여기서 말하는 신뢰성이란 전송되는 데이터 패킷들의 순서, 패킷 유실 여부 등 데이터를 전송하려는 쪽이 보낸 모든 데이터가 온전하게 받는 쪽에 전달이 되었느냐를 말하는 것이다.

이때 TCP는 클라이언트와 서버가 서로 신뢰성있는 통신을 할 수 있도록 몇 가지 방법을 사용하게되는데, 이 과정 또한 결국은 클라이언트와 서버 간의 통신이기 때문에 약간의 레이턴시가 발생할 수 밖에 없다. 이 과정은 TCP라는 프로토콜이 생길 때부터 정의된 `표준`이므로 함부로 건너뛸 수도 없다.

HTTP/3이 UDP 기반인 QUIC 프로토콜을 사용하는 이유가 바로 이 과정에 소비하는 시간이 아까우니까 다른 방법을 사용해보자는 아이디어에서 출발한 것이다. 그럼 한번 TCP가 신뢰성 있는 통신을 위해 어떤 방법을 사용하는지 간략하게 짚고 넘어가보도록 하자.

### 3 Way Handshake
TCP는 굉장히 친절한 프로토콜이다. 통신을 시작할 때와 종료할 때 클라이언트와 서버가 준비가 되어있는지를 반드시 먼저 물어보고 나서야 본격적인 통신을 시작하기 때문이다.

이때 통신을 시작할 때 거치는 과정을 `3 Way Handshake`, 통신을 마칠 때 거치는 과정을 `4 Way Handshake`라고 한다. 이 포스팅의 목적은 이 과정을 자세히 다루는 것이 아니므로, TCP를 사용하여 통신을 시작할 때 거치는 과정인 3 Way Handshake가 어떤 원리로 작동하는지만 간단하게 설명하겠다.

<center>
  {% asset_img 3way-handshake.png 500 %}
  <small>통신을 시작할 때 3 Way Handshake를 하는 과정</small>
  <br>
</center>

위 그림을 보면 클라이언트가 처음 서버와 통신을 하기 위해 TCP 연결을 생성할 때 `SYN`와 `ACK`이라는 값을 주고 받고 있는데, 이 과정에는 총 3번의 통신이 필요하다. 패킷의 순서와 데이터 전송 완료 여부를 체크하는 것이다. OSX를 사용하고 있는 분이라면 터미널에서 `tcpdump` 유틸리티를 사용하여 이 과정을 직접 눈으로 확인해볼 수 있다.

단, `tcpdump`를 아무 옵션 없이 사용하면 디바이스의 모든 패킷을 감시하고 출력하기 때문에 원하는 정보를 찾기 힘들다. 그래서 필자는 루프백에서 돌고 있는 이 블로그 서버와의 통신만 캡쳐할 것이다.

```bash
$ sudo tcpdump host localhost -i lo0
IP localhost.53920 > localhost.terabase: Flags [S], seq 1260460927, win 65535
IP localhost.terabase > localhost.53920: Flags [S.], seq 3009967847, ack 1260460928, win 65535
IP localhost.53920 > localhost.terabase: Flags [.], ack 1, win 6379
```

이 로그에서 `localhost.53920`은 클라이언트, `localhost.terabase`는 서버이다. 각 라인의 `[S]` 플래그는 Sync 패킷, `[S.]` 플래그는 SynAck 패킷, `[.]`은 아무 플래그도 설정되지 않았음을 의미한다. 그리고 각 플래그의 우측에는 패킷에 어떤 정보들을 담아서 보냈는지 보여주고 있다.
이 로그가 뭘 의미하는 지 한번 순서대로 살펴보자.

{% blockquote %}
1. 클라이언트가 서버에게 `seq=1260460927`라는 시퀀스 동기화 번호를 보냄
2. 서버는 요청으로 받은 시퀀스 번호를 1 증가시켜서 `ack=1260460928` 필드에 담아 보냄
3. 클라이언트는 서버로부터 받은 `ack` 값과 자신이 보냈던 `seq` 값의 차를 자신의 요청의 `ack` 값으로 설정하고 다시 서버에 응답한다.
{% endblockquote %}

이때 두번째 과정에서 서버는 클라이언트가 처음에 보낸 `seq` 값을 1 증가 시킨 후 자신의 `ack` 필드에 담아서 보내는데, `지금 이 응답이 니가 보낸 1260460927번 요청과 관련 있음`이라고 증명하고 있는 것이다. 그리고 서버로부터 다시 패킷을 받은 클라이언트는 자신의 `ack` 값에 자신이 맨 처음 보낸 `seq` 값과 서버가 응답으로 보내준 `ack` 값의 차를 자신이 보낼 패킷의 `ack` 값으로 사용함으로써 이 연결이 유효하다는 것을 증명한다.

여기까지가 TCP에서 연결을 새로 만들 때 거치는 과정인 3 Way Handshake인 것이다. 이 과정을 통해 클라이언트와 서버는 데이터를 주고 받을 준비가 되었다는 것을 서로에게 알려주고 이후 데이터 전송에 필요한 시퀀스 번호를 알 수 있게 된다. 연결을 끊을 때도 마찬가지로 이런 비슷한 과정인 4 Way Handshake를 거치고 나서야 세션을 종료할 수 있다.

즉, TCP를 사용하는 이상 본격적인 통신을 시작하기 전에 무조건 이 과정을 거쳐야한다는 것이다. 


## QUIC
QUIC는 구글이 TCP가 가지고 있는 레이턴시의 한계를 뛰어넘고자 UDP를 기반으로 개발한 프로토콜이다.
이미 알게 모르게 Chrome에서는 QUIC를 사용하여 통신을 하고 있었고, GCP에서도 `QUIC negotioation`이라는 기능을 통해 해당 프로토콜을 이미 제공하고 있었다.

## HTTP/2와의 차이점

