---
title: HTTP/3에 대해 알아보자(가제)
toc: true
widgets:
  - type: toc
    position: right
  - type: category
    position: right
sidebar:
  right:
    sticky: true
tags:
categories:
  - Programming
  - Network
thumbnail:
---

`HTTP/3`는 `HTTP(Hypertext Transfer Protocol)`의 세 번째 메이저 버전으로, 기존의 HTTP/1, HTTP/2와는 다르게 UDP 기반의 프로토콜인 `QUIC`를 사용하여 통신하는 프로토콜이다. HTTP/3와 기존 HTTP 들과 가장 큰 차이점이라면 TCP가 아닌 UDP 기반의 통신을 한다는 것이다.

<!-- more -->

필자는 최근에 다른 분들이 공유해주시는 포스팅을 보고 나서 HTTP/3가 나왔다는 것을 처음 알게 되었다. 그 포스팅은 [HTTP/3: the past, the present, and the future](https://blog.cloudflare.com/http3-the-past-present-and-future/)라는 포스팅이었는데, 솔직히 처음 딱 제목만 보고나서 이런 생각을 했었다.

> 아니, HTTP/2가 공개된지 4년 정도 밖에 안 지났는데 무슨 HTTP/3가 벌써 나와? 그냥 설계하고 있다는 거 아니야?

그런데 포스팅을 읽어 보니 이미 Google Chrome은 HTTP/3를 지원하는 카나리 빌드도 배포되어 있어서 실제로 사용까지 해볼 수 있는 단계에 도달했다는 사실을 알게 되어 놀랐다. HTTP/1에서 HTTP/2로 가는 데만 해도 대략 15년 정도의 시간이 걸렸는데, 고작 4년 만에 바로 사용해볼 수 있는 정도의 완성도인 다음 메이저 버전이 배포되었다는 것이다.

프로그래밍 언어나 프레임워크같은 친구들은 배포하는 쪽에서 업데이트를 쫙 해버리고 유저들이 업데이트를 하면 그만이지만, 프로토콜은 일종의 규약이기 때문에 소프트웨어 제조사 간 합을 맞추는 기간이 필요하므로 이렇게 단기간 안에 급격한 변화가 자주 발생하지 않을 것이라고 생각했다. 아무리 요즘 기술의 변화가 빠르다지만, HTTP는 나름 웹의 근간이 되는 프로토콜인데 꼴랑 4년 만에 이런 급격한 변화가 일어났다는 게 놀라울 따름이다.<small>(몇 달 전에 HTTP/2를 처음 도입해본 웹 개발자는 웁니다)</small>

<center>
  {% asset_img ce-http2.png 500 %}
  <small>W3Techs.com에서 조사한 2019년 8월 HTTP/2 사용률</small>
  <br>
</center>

그리고 또 한가지 놀랐던 점은 HTTP/3는 `TCP`가 아닌 `UDP`를 사용한다는 것이었다. 뭐 딱히 웹 프로토콜이 무조건 TCP만 사용해야 한다는 법이 있는 건 아니긴 하지만, 학교에서 배울 때도 그렇고 실무에서도 실제로 사용할 때도 그렇고 `HTTP는 TCP 위에서 정의된 프로토콜`이라는 사실이 너무 당연하게 인식되어 있었기 때문에 UDP를 사용한다는 점이 신기하기도 했고 "왜 멀쩡히 잘 돌아가는 TCP를 냅두고 UDP를 사용하는거지?"라는 의문도 들었다.

사실 HTTP/3는 정식으로 배포된 프로토콜이라기보다 아직 테스트를 거치고 있는 단계라고 보는 게 맞다. 하지만 위에서 이야기 했듯이 Google Chrome은 이미 HTTP/3를 지원하는 카나리 빌드를 배포한 상태이고, Mozila Firefox도 조만간 Nightly 버전에서 HTTP/3를 지원할 예정이며, cURL에서도 HTTP/3를 실험적 기능으로 제공하고 있는 만큼 가까운 미래 안에 HTTP/3가 메인 프로토콜이 될 가능성이 높은 것도 사실이다.

만약 Google Chrome에서 HTTP/3 프로토콜을 사용해보고 싶다면 터미널에서 `--enable-quic`과 `--quic-version=h3-23` 인자를 사용하여 실행하면 된다.

```bash
$ open -a Google\ Chrome --args --enable-quic --quic-version=h3-23
```

<center>
  {% asset_img http3-demo.png 500 %}
  <small>`http/2+quic/46`이라고 되어있는 녀석들이 HTTP/3 프로토콜을 사용한 연결이다</small>
  <br>
</center>

필자는 웹 개발자이기 때문에 HTTP가 메이저 업데이트 된다는 사실을 그냥 넘기기는 힘들었고, UDP를 사용한다는 것이 뭘 의미하는지도 궁금하기도 해서 결국 HTTP/3에 대한 조사를 하게 되었다. 그래서 이번 포스팅에서는 필자가 여기저기 쑤셔보면서 알아본 HTTP/3에 대한 내용을 정리해볼까 한다.

## HTTP/3에 대한 간단한 소개
사실 `HTTP/3`는 처음에는 `HTTP-over-QUIC`이라는 이름을 가지고 있었는데, `IETF(Internet Engineering Task Force)` 내 HTTP 작업 그룹과 QUIC 작업 그룹의 의장인 마크 노팅엄이 이 프로토콜의 이름을 HTTP/3로 변경할 것을 제안했고, 2018년 11월에 이 제안이 통과되어 HTTP-over-QUIC이라는 이름에서 HTTP/3으로 변경되게 되었다.

즉, HTTP/3는 `QUIC`이라는 프로토콜 위에서 돌아가는 HTTP인 것이다. QUIC는 `Quick UDP Internet Connection`의 약자로, 말 그대로 UDP를 사용하여 인터넷 연결을 하는 프로토콜이다. HTTP/3는 QUIC를 사용하고, QUIC는 UDP를 사용하기 때문에 결과적으로 `HTTP/3는 UDP를 사용한다` 라고 이야기 할 수 있는 것이다.

그렇다면 QUIC이 도대체 뭐길래 기존의 TCP보다 더 빠른 전송 속도를 가질 수 있다는 것일까? 그 이유를 알려면 먼저 TCP가 왜 느리다고 하는지, UDP를 사용함으로써 어떤 이득을 얻을 수 있는지 부터 알아야 한다.

## TCP가 왜 느린데?
필자는 학교에서 네트워크 강의를 들을 때 `TCP`와 `UDP`의 차이에 대한 내용을 처음 배웠었는데, 교수님이 이건 반드시 시험에 나온다길래 이런 표를 보면서 열심히 외웠던 기억이 난다.

| | TCP | UDP |
|---|---|---|
| 연결 방식 | 연결형 서비스 | 비연결형 서비스 |
| 패킷 교환 | 가상 회선 방식 | 데이터그램 방식 |
| 전송 순서 보장 | 보장함 | 보장하지 않음 |
| 신뢰성 | 높음 | 낮음 |
| 전송 속도 | 느림 | 빠름 |

위 표를 보면 대략 TCP는 `신뢰성이 높고 느리다`, UDP는 `신뢰성이 낮고 빠르다` 정도로 정리가 되는데, 여기서 말하는 신뢰성이란 전송되는 데이터 패킷들의 순서, 패킷 유실 여부 등 데이터를 전송하려는 쪽이 보낸 모든 데이터가 온전하게 받는 쪽에 전달이 되었느냐를 말하는 것이다.

이때 TCP는 클라이언트와 서버가 서로 신뢰성있는 통신을 할 수 있도록 몇 가지 방법을 사용하게되는데, 이 과정 또한 결국은 클라이언트와 서버 간의 통신이기 때문에 약간의 레이턴시가 발생할 수 밖에 없다. 이 과정은 TCP라는 프로토콜이 생길 때부터 정의된 `표준`이므로 함부로 건너뛸 수도 없다.

HTTP/3이 UDP 기반인 QUIC 프로토콜을 사용하는 이유가 바로 이 과정에 소비하는 시간이 아까우니까 다른 방법을 사용해보자는 아이디어에서 출발한 것이다. 그럼 한번 TCP가 신뢰성 있는 통신을 위해 어떤 방법을 사용하는지 한번 알아보자.

### 3 Way Handshake
TCP는 굉장히 친절한 프로토콜이다. 통신을 시작할 때와 종료할 때 클라이언트와 서버가 준비가 되어있는지를 반드시 먼저 물어보고 나서야 본격적인 통신을 시작하기 때문이다.

이때 통신을 시작할 때 거치는 과정을 `3 Way Handshake`, 통신을 마칠 때 거치는 과정을 `4 Way Handshake`라고 한다. 이 포스팅의 목적은 이 과정을 자세히 다루는 것이 아니므로, TCP를 사용하여 통신을 시작할 때 거치는 과정인 3 Way Handshake가 어떤 원리로 작동하는지만 간단하게 설명하겠다.

<center>
  {% asset_img 3way-handshake.png 500 %}
  <small>통신을 시작할 때 3 Way Handshake를 하는 과정</small>
  <br>
</center>

위 그림을 보면 클라이언트가 처음 서버와 통신을 하기 위해 TCP 연결을 생성할 때 `SYN`와 `ACK`이라는 값을 주고 받고 있다. 이 값들을 사용하여 클라이언트와 서버가 서로 보낸 요청이 유효한 지 확인할 수 있는 것이다. 그리고 이 과정에는 총 3번의 통신이 필요하다. OSX나 Linux를 사용하고 있는 분이라면 터미널에서 `tcpdump` 유틸리티를 사용하여 이 과정을 직접 눈으로 확인해볼 수 있다.

단, `tcpdump`를 아무 옵션 없이 사용하면 디바이스의 모든 패킷을 감시하고 출력하기 때문에 원하는 정보를 찾기 힘들다. 그래서 필자는 루프백에서 동작하고 있는 블로그 서버와의 통신만 캡쳐해보았다.

```bash
$ sudo tcpdump host localhost -i lo0
IP localhost.53920 > localhost.terabase: Flags [S], seq 1260460927, win 65535
IP localhost.terabase > localhost.53920: Flags [S.], seq 3009967847, ack 1260460928, win 65535
IP localhost.53920 > localhost.terabase: Flags [.], ack 3009967848, win 6379
```

> 보낸 놈 > 받은 놈: Flags [플래그 종류], 헤더의 값들

원래는 이것보다 더 많은 정보가 나오지만, 여기에 전부 기재하기에는 양이 너무 많으니 설명에 필요한 정보만 추려보았다. 이 로그에서 중요한 키워드는 `Flag`, `seq`, `ack` 정도이다. 한번 하나하나 뜯어보도록 하자.

먼저 `localhost.53920`은 클라이언트, `localhost.terabase`는 서버를 의미한다. 각 라인의 첫번째 필드는 `보낸 놈 > 받은 놈`을 의미하고 있으니, 첫 패킷은 클라이언트가 서버에게, 두 번째 패킷은 서버가 클라이언트에게 보낸 것이라고 할 수 있다. 그리고 각 라인에는 `Flag`라는 것이 붙어있는데, 플래그는 이 패킷이 어떤 타입의 패킷인지를 알려주는 역할을 한다.

| Flag | 이름 | 의미 |
|------|-----|-----|
| S | SYN | 연결을 생성할 때 클라이언트가 서버에 시퀀스 번호를 보내는 패킷 |
| S. | SYN-ACK | 시퀀스 번호를 받은 서버가 ACK 값을 생성하여 클라이언트에게 응답하는 패킷 |
| . | ACK | ACK 값을 사용하여 응답하는 패킷 |

이 통신 과정을 거치고 나면 클라이언트와 서버는 신뢰성 있는 TCP 연결을 생성할 수 있고, 이때 총 3회의 통신을 하기 때문에 3 Way Handshake라고 하는 것이다.

그렇다면 이 과정에서 어떤 일이 벌어지길래 신뢰성 있는 연결을 생성할 수 있다는 것일까? 조금 더 자세히 들여다보면 클라이언트와 서버는 3 Way Handshake를 할 때 대략 이런 과정을 거치고 있다.

{% blockquote %}
1번 라인: 클라이언트가 서버로 시퀀스 번호를 `seq` 필드에 담아 보냄
2번 라인: 서버는 클라이언트가 보내준 시퀀스 번호를 1 증가시켜서 `ack` 필드에 담아 보냄
3번 라인: 클라이언트는 다시 서버로부터 받은 시퀀스 번호를 1 증가시켜서 자신의 `ack` 필드에 담아 보냄
{% endblockquote %}

새로운 TCP 연결을 생성하고자 할 때 클라이언트가 서버에게 랜덤한 시퀀스 번호를 전송함으로써 3 Way Handshake가 시작된다. 이때 생성된 시퀀스 번호는 이후 송신 측이 전송한 패킷을 수신 측이 재조립할때 패킷의 조립 순서를 알려주는 역할을 한다.

이때 클라이언트와 서버는 상대방이 보내준 `seq(시퀀스 번호)`를 1 증가 시킨 후 자신의 `ack(승인 번호)` 필드에 담아서 보내는데, "지금 이 패킷이 니가 전에 보낸 시퀀스 번호의 다음으로 이어지는 패킷이야"라고 말하고 있는 것이다.

이 3회의 통신이 바로 3 Way Handshake이다. 이 과정을 통해 클라이언트와 서버는 데이터를 주고 받을 준비가 되었다는 것을 서로에게 알려주고 이후 데이터 전송에 필요한 시퀀스 번호를 알 수 있게 된다. 연결을 끊을 때도 마찬가지로 이런 비슷한 과정인 4 Way Handshake를 거치고 나서야 세션을 종료할 수 있으며, 이때는 총 4회의 통신을 통해 연결을 종료한다.

즉, TCP를 사용하는 이상 본격적인 통신을 시작하기 전에 무조건 번거로운 통신 과정을 거쳐야한다는 것이다. 그리고 이 외에도 TCP가 가지고 있는 레이턴시의 원인이 되는 문제가 하나 더 있다.

### HOLB(Head of line Blocking)
바로 `HOLB(Head of Line Blocking)`이라고 하는 문제이다. TCP를 사용한 통신은 신뢰성을 최우선으로 하기 때문에 통신 중간에 패킷이 유실되면 절대로 그냥 넘어가지 않는다. 무조건 송신 측은 수신 측이 패킷을 제대로 다 받았다는 것을 확인하고 나서야 다음 패킷을 보낸다는 이야기이다.




## QUIC
QUIC는 구글이 TCP가 가지고 있는 레이턴시의 한계를 뛰어넘고자 UDP를 기반으로 개발한 프로토콜이다.
이미 알게 모르게 Chrome에서는 QUIC를 사용하여 통신을 하고 있었고, GCP에서도 `QUIC negotioation`이라는 기능을 통해 해당 프로토콜을 이미 제공하고 있었다.

## HTTP/2와의 차이점

