---
title: 홀수와 짝수를 사용하여 문제를 단순화해보자!
toc: true
widgets:
  - type: toc
    position: right
  - type: category
    position: right
sidebar:
  right:
    sticky: true
tags:
categories:
  - Programming
  - Algorithm
thumbnail:
---

최근 많은 IT 기업들이 개발자를 채용할 때 코딩 테스트를 시행하고 있다. 회사마다 어떤 스타일의 문제를 출제하는지 차이는 있지만, 대부분 간단한 알고리즘 풀이 또는 `Codility`나 `프로그래머스`와 같은 사이트처럼 실무에서 겪을 만한 상황을 살짝 섞어놓는 느낌의 문제를 선호하는 것 같다.

<!-- more -->

이런 문제들의 특성 상 CS 기초와 수학적 사고, 센스 등을 다양하게 사용하여 풀어야하기 때문에 단기간 연습한다고 실력이 확 느는 것은 아닌 것 같다.

사실 자료구조나 알고리즘은 공부하고 몇 번 구현해보면 어느 정도 숙달될 수 있다. 하지만 이런 문제를 풀 때는 단순히 `트리 중위 순회를 알고 있냐`가 아니라 `이 문제가 트리 중위 순회로 푸는 문제냐`를 알고있는 것이 더 중요하다.

즉, 문제를 분석하고 단순화해서 어떤 방법을 사용할 것인지를 판단할 수 있는 능력이다.

필자는 최근 취업 준비를 하면서 이런 문제를 종종 풀어보고 있는데, 확실히 CS 기초도 부족하긴 하지만, 적절한 자료구조나 알고리즘을 선택하는 능력이 더 부족하다는 것을 느꼈다.

그래서 자료구조나 알고리즘을 처음부터 다시 공부하면서, 동시에 이 능력을 기르기 위한 훈련도 필요하다고 생각했다.

## 수학적인 사고 방식으로 문제를 단순화하자
필자가 최근 문제를 풀어나가면서 한 가지 느꼈던 것이, 스스로 알고리즘이나 자료구조에 너무 얶매이고 있었다는 사실이다.

대부분 알고 있겠지만, 대부분의 코딩 테스트 문제은행 서비스는 문제를 해결하고 나면 다른 사람들은 이 문제를 어떤 방식으로 해결했는지 볼 수 있다. 필자같은 경우는 사실 이게 궁금해서 문제를 푸는 것도 있는 것 같다.

그러던 와중에 대부분의 사람들이 완전탐색으로 풀었던 문제를 어떤 굇수 분이 단순한 산수 연산 몇 번으로 풀어내는 것을 본 적이 있었다.

<center>
  {% asset_img genius.jpg 350 %}
  <small>역시 세상은 넓고 굇수는 많다</small>
  <br>
</center>

이때 필자가 느낀 점은, `수학적인 사고`에 대한 필요성이었다. 사실 필자도 해당 문제를 완전탐색으로 풀었고 그 방법 밖에 없을 것이라고 생각했지만, 그 굇수분은 수학적인 사고 방식을 통해 문제를 단순화시켰고, 패턴을 찾아낸 것이다.

이전에 {% post_link programmer-with-math 프로그래머는 수학을 잘해야할까? %}에서도 한번 이야기한 적 있지만, 필지가 이야기하는 수학은 `홀수와 짝수`, `집합`, `명제` 등 우리가 어린 시절에 다 한번씩 배우는 정도의 수학을 이야기하는 것이다.

물론 머신러닝이든 영상처리든 수학이 굉장히 중요한 분야도 있지만, 대부분의 프로그래머가 겪는 문제의 해결 방법에는 `푸리에 급수`와 같은 복잡한 이론은 필요없다.

그래서 이번 포스팅에서는 수학을 사용하여 문제를 단순화하는 방법 중 하나인 `주기성`에 대해서 한번 이야기해보려고 한다.

주기성을 찾거나 만들어내는 상황은 굉장히 자주 접할 수 있는 상황이다. 간단한 예로 `n의 배수`를 찾아내는 문제가 있겠다.

```js
[1, 3, 4, 8, 2, 16].forEach(num => {
  console.log('4의 배수인가?', num % 4 === 0);
});
```

배수를 찾아내는 것이 왜 주기성과 관련이 있냐고 물어볼 수 있겠지만, 결국 배수라는 것은 `n의 주기마다 반복되어 나타나는 수`이기 때문에 주기와 관련이 깊다.

방금 예시로 봤던 `4의 배수`를 살펴보면 `4, 8, 12, 16, 20...`처럼 4씩 커지면서 증가하고 있는 수이기 때문에 주기가 있다고 말할 수 있다.

이런 식으로 주기성을 찾아낼 수만 있다면 도저히 풀 수 없을 것 같은 큰 문제도 생각보다 간단하게 풀어낼 수 있다.

## 오늘로부터 100억일 후는 무슨 요일일까?
필자가 이 글을 작성하고 있는 `2019년 10월 29일`은 `화요일`이다. 그럼 오늘로부터 100억일 후는 과연 무슨 요일일까?

음, 단순하게 생각해보면... 오늘은 화요일이니까 1일 후는 수요일, 2일 후는 목요일과 같은 순차적인 방법으로 접근할 수도 있겠다.

```js
console.time('calc');
const week = ['일', '월', '화', '수', '목', '금', '토'];
let today = 2;
let shift = 0;

for (let i = 0; i <= Math.pow(10, 10); i++) {
  shift = i % week.length;
}

today += shift;
if (today > week.length - 1) {
  today -= week.length;
}
console.log(week[today]);
console.timeEnd('calc');
```
```
토
calc: 60948.138ms
```

아무리 요즘 컴퓨터의 연산 능력이 좋다고 해도 100억회를 반복하는 루프는 컴퓨터를 사랑하는 사람이 할 짓이 아니다. 이 알고리즘은 시간 복잡도가 $O(n)$이기에, 루프만 돌았을 뿐인데도 수행 시간이 1분이 넘는다.

이렇게 무식하게 풀어낼 수는 없으니, 다른 방법을 찾아야한다. 다행히 우리는 요일이 `7`일 마다 반복된다는 것을 알고 있다. 오늘은 화요일이라면 7일 후도 당연히 화요일일 것이고, 14일 후도 화요일일 것이기 때문이다. 즉, 오늘부터 `7의 배수`가 지난 날이라면 무조건 화요일이라는 이야기가 된다.

여기까지 생각이 닿았다면 그 다음부터는 간단해진다. 배수를 구할 때와 마찬가지로 `100억`을 `7`로 나누고 그 나머지를 확인하면 되기 때문이다.

```js
console.time('calc');
const week = ['일', '월', '화', '수', '목', '금', '토'];
let today = 2;
let shift = Math.pow(10, 10) % week.length;

today += shift;
if (today > week.length - 1) {
  today -= week.length;
}
console.log(week[today]);
console.timeEnd('calc');
```
```
토
calc: 0.156ms
```

수행 시간이 `60000ms`에서 `0.1ms`로 줄었다. 이렇게 문제에서 주기성을 찾아낼수만 있다면 완전탐색을 하지 않고도, 나머지를 사용하여 문제를 가볍게 풀 수 있다.

### $10^{100000000}$일 후의 요일도 구해보자
자, 그럼 여기서 한번 더 나아가보자. 이런 방법으로 우리가 $10^{100000000}$일, 즉 `10의 1억승`일 이후의 요일도 구할 수 있을까? 10의 1억승을 뭐라고 부르는지는 모르겠지만, $10^{68}$이 무량대수라고 부르는 엄청 큰 숫자이니 쉽게 가늠이 안되는 수인 것은 분명하다.

당연히 $10^{100000000}$은 자바스크립트의 `Number.MAX_SAFE_INTEGER` 값을 아득히 넘어서는 숫자이기 때문에 위와 같은 방식으로는 계산도 불가능 하다. 여기서부터는 컴퓨터한테 계산을 맡기는 것보다는 문제를 단순화하고 주기성을 찾아내는 일이 더 중요해진다.

오늘은 `10월 29일 화요일`이니 오늘부터 $n$일 후의 요일을 쭉쭉 살펴보도록 하자. 방금 예제로 만들었던 로직을 활용하여 $10^{30}$일 이후까지 살펴보니, 대략 다음과 같은 패턴이 있다는 것을 알 수 있었다. 모든 결과를 적으면 너무 표가 길어지니, $10^{12}$일 이후의 결과만 기재하도록 하겠다.

| 일자 | 요일 | 인덱스 |
|-----|-----|------|
| $10^0$일 후 | 수 | 3 |
| $10^1$일 후 | 금 | 5 |
| $10^2$일 후 | 목 | 4 |
| $10^3$일 후 | 월 | 1 |
| $10^4$일 후 | 토 | 6 |
| $10^5$일 후 | 일 | 0 |
| $10^6$일 후 | 수 | 3 |
| $10^7$일 후 | 금 | 5 |
| $10^8$일 후 | 목 | 4 |
| $10^9$일 후 | 월 | 1 |
| $10^{10}$일 후 | 토 | 6 |
| $10^{11}$일 후 | 일 | 0 |
| $10^{12}$일 후 | 수 | 3 |

필자는 여기서 대략 두 가지 정보를 얻을 수 있었다. 요일이 `수, 금, 목, 월, 토, 일`의 순서로 계속 반복되고 있다는 것과 오늘 요일인 `화요일`이 등장하지 않는다는 것이다.

즉, 10의 지수가 6 증가할 때마다 같은 요일이 돌아온다. 바꿔말하면 0의 개수가 6개씩 늘어날 때마다 같은 요일이 돌아온다는 말과 같다.

그렇다면 결국 10의 지수를 6으로 나눈 나머지 값을 사용하여 방금 전과 동일한 방법으로 요일을 구할 수 있다는 말이다.

```js
const week = ['수', '금', '목', '월', '토', '일'];
const exp = Math.pow(10, 8);

console.log(week[exp % week.length]);
```
```
토
```

비록 $10^{100000000}$이라는 어마무시한 수를 컴퓨터가 담아낼 수 없기 때문에 직접 계산할 수는 없지만, 지수의 증가로 인한 요일의 주기를 파악함으로써 상상도 안가는 먼 미래의 요일을 구할 수 있게 되었다.<small>(사실 이걸 구하는 게 뭔 의미가 있겠냐만...)</small>

만약 위에서 요일을 구했던 정직한 방법으로 이 문제를 풀려고 했다면 불가능했겠지만, 문제를 분석하고 주기성을 찾아냄으로써 어찌어찌 풀 수는 있었다.

## 타일 깔기
사실 방금 풀어보았던 요일 맞추기 문제처럼 눈에 띄게 일정한 주기를 가지고 반복되는 숫자를 찾아내는 문제는 익숙해지는 데 그렇게 오랜 시간이 걸리지는 않는다.

그러나 주기성의 진짜 의의는 바로 `패턴`을 만들고 찾아낼 수 있다는 것에 있다. 이번에는 그 패턴을 이용하여 유효성을 검사하는 문제이다.

<center>
  {% asset_img tile.png 500 %}
  <br>
</center>

{% blockquote %}
에반은 타일 시공 업체에 취직해서 첫 욕실 바닥 시공을 하게 되었다.
그러나 에반은 실수로 가로 1cm, 세로 2cm의 직사각형 타일들만 챙겨나오게 되었다...

다행히 모든 욕실 바닥은 표준화가 되어있어서 가로 1cm, 세로 1cm의 정사각형 칸으로 이루어져있지만, 욕실 바닥 모양과 칸의 수는 모두 제각각이다.

에반은 자신의 직사각형 타일로 욕실 바닥을 빠짐없이 메꿔야하지만, 욕실 바닥의 모양에 따라 작업이 불가능한 곳도 있다.
게다가 에반은 힘이 없어서 타일을 반으로 쪼개서 사용할 수도 없다.

에반은 어떻게 작업의 가능 여부를 알 수 있을까?
{% endblockquote %}

```js
const floor = [
  [0, 0, 0, 0, 0, 1, 0, 0],
  [0, 1, 1, 1, 1, 1, 0, 0],
  [1, 1, 1, 1, 1, 1, 0, 0],
  [1, 1, 1, 1, 1, 1, 0, 1],
  [1, 1, 1, 1, 1, 1, 1, 1],
  [0, 0, 0, 0, 1, 1, 1, 1],
  [0, 0, 0, 0, 1, 1, 1, 0],
];
```

이 문제의 경우, 타일로 욕실 바닥을 채울 수 있는 경우의 수를 하나하나 따져보자면 답이 없다.

그렇다면 욕실 바닥에 있는 칸의 개수를 세어보면 어떨까? 만약 칸의 개수가 홀수라면 에반이 가진 타일로는 절대 바닥을 채울 수가 없다.

하지만 이 문제에 나와있는 바닥의 총 칸 수는 슬프게도 `34`칸이다. 게다가 홀수, 짝수 여부만으로는 해당 타일로 전부 바닥을 채울 수 있을지는 장담할 수 없다. 조금 더 확실한 검증 방법이 없을까?

이 문제는 주기성과 전혀 관련이 없을 것 같지만, 사실 굉장히 간단한 주기가 숨어있다. 바로 에반이 가지고 있는 타일이 두개의 칸으로 이루어져 있다는 것이다.

조금 더 생각을 쉽게 하기 위해 타일과 바닥에 색을 칠해보도록 하자.

<center>
  {% asset_img tile-fill.png 500 %}
  <br>
</center>

이렇게 색을 칠하고나니 에반이 가지고 있는 타일은 `검은색 1칸`과 `흰색 1칸`으로 이루어진 두 칸짜리 타일이 되었다. 즉, 만약 에반이 가지고 있는 타일로 욕실의 바닥을 빈틈없이 메꿀 수 있다면, 욕실 바닥의 검은색 칸의 수와 흰색 칸의 수가 같아야 한다는 것이다.

그러나 우리에게 주어진 욕실 바닥의 검은색 칸의 수는 `16`칸, 흰색 칸의 수는 `18`칸이다. 즉, 이 욕실 바닥은 에반이 가진 타일로는 채울 수 없는 바닥이라는 뜻이 된다.

이 문제는 단순히 두 칸으로 이루어진 에반의 타일에 `검은색`과 `흰색`이라는 주기성을 부여하여 풀어나가는 문제이다. 에반의 타일이 가지고 있는 색의 주기와 욕실 바닥의 주기가 동일하지 않다면 그 욕실 바닥은 `채울 수 없는 바닥`이 되는 것이다.

그럼 검은색 칸을 `-1`, 흰색 칸을 `1`으로 정의하고, 욕실 바닥의 해당 칸을 만날 때마다 `-1`과 `1`을 번갈아가며 더한 후 마지막에 값이 `0`이 되면 검은색 칸과 흰색 칸의 수가 동일하다고 생각할 수 있겠다.

```js
const floor = [
  [0, 0, 0, 0, 0, 1, 0, 0],
  [0, 1, 1, 1, 1, 1, 0, 0],
  [1, 1, 1, 1, 1, 1, 0, 0],
  [1, 1, 1, 1, 1, 1, 0, 1],
  [1, 1, 1, 1, 1, 1, 1, 1],
  [0, 0, 0, 0, 1, 1, 1, 1],
  [0, 0, 0, 0, 1, 1, 1, 0],
];
const tile = [-1, 1];

let count = 0;
let tileIndex = 0;

floor.forEach((row, index) => {
  tileIndex = Number(index % 2 === 0);
  row.forEach(col => {
    if (col === 1) {
      count += tile[tileIndex];
    }
    tileIndex = tileIndex === 0 ? 1 : 0;
  });
});

console.log(`검은 타일과 흰 타일의 개수 차이는 ${Math.abs(count)} 입니다.`);
```
```
검은 타일과 흰 타일의 개수 차이는 2 입니다.
```

각 `row`를 순회할 때 `tileIndex`를 다시 교정해주는 이유는, 이 행렬의 컬럼의 개수가 짝수이기 떄문이다. 타일의 주기 또한 짝수이기에 다음 줄에서는 이전 줄의 가장 마지막에 있던 타일의 색이 다시 한번 나오게 된다.<small>(컬럼을 홀수로 만들면 이 과정이 필요없는데, 문제 잘못 만들었다...)</small>


