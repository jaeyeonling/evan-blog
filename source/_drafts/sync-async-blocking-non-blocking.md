---
title: 동기와 비동기에 대해서
toc: true
widgets:
  - type: toc
    position: right
  - type: category
    position: right
sidebar:
  right:
    sticky: true
tags:
categories:
thumbnail:
---

이번 포스팅에서는 I/O와 네트워크 등 전반적으로 다양한 모델에서 사용하는 개념인 `동기(Synchronous)와 비동기(Asynchronous)`에 대해서 한번 이야기 해보려고 한다. 그리고 이 두가지 개념과 많이 혼동되는 개념인 `블록킹(Blocking)과 논블록킹(Non-Blocking)`에 대해서도 간단하게 한번 짚고 넘어갈 예정이다.

<!-- more -->

본격적인 포스팅에 들어가기에 앞서 한가지 확실하게 이야기하고 싶은 것은 동기와 비동기는 `프로세스간 커뮤니케이션에 대한 매커니즘`이고 블록킹과 논블록킹은 `프로그램의 제어권에 대한 개념`으로, 서로 직접적인 관련이 전혀 없는 별개의 개념들이라는 것이다.

이미 많은 능력자 분들이 이 주제에 대해서 잘 정리해놓은 포스팅들이 있지만, 대부분 이 개념들을 함께 다루고 있기 때문에, 이 개념들을 처음 접하거나 컴퓨터 공학에 대한 이해가 없는 사람은 이 두 가지 개념들이 서로 뭔가 연관이 있는 것으로 오해하기 쉽다고 생각하여 이 점을 분명히 하려고 한다.

그래서 이번 포스팅에서는 이 각각의 용어가 정확히 무엇을 의미하는지 설명하고 이 4가지 개념이 서로 결합하는 케이스가 어떠한 상황을 의미하는 것인지를 한번 설명해보려고 한다.

## 동기와 비동기
`동기(Synchronous)`와 `비동기(Asynchronous)`는 프로세스 또는 함수 간의 커뮤니케이션에 대한 매커니즘을 의미한다. 필자는 처음 학교에서 이 개념을 배웠을 때 직관적으로 이해가 힘들다고 생각했는데, 그 이유는 바로 `동기`라는 단어 때문이다.

사실 `블록킹` 같은 단어는 농구같이 일상에서 접할 수 있는 스포츠에서도 사용하고 있는데다가 `뭔가를 막는다`라는 뜻이 바로 와닿기 때문에 조금 이해하기 쉬운 편이지만 동기는 조금 다르다.

대부분의 포스팅에서 동기의 의미를 설명할 때 `어떤 사건이 동시에 발생하는 것`으로 간단히 설명하고 넘어가고 있지만, 문제는 이 의미가 우리가 일반적으로 접하는 동기의 의미와 조금 다르다는 것이다.

우리가 일상에서 주로 접하는 동기의 예는 바로 `동기화(Synchronization)`이다. 예를 들면 아이폰에 음악을 넣을 때 아이튠즈에서 사용하는 동기화 기능 같은 것 말이다. 이때 동기화는 `서로 다른 상태를 같은 것으로 만드는 것`을 의미하는데, 컴퓨터 공학에서 사용하는 동기의 의미와는 느낌이 조금 다르다.

그래서 우리는 이 단어가 정확히 무엇을 의미하는지부터 생각해 볼 필요가 있다. 왜 동기라는 단어는 이렇게 다른 상황에서 사용되고 있는 것일까?

### 동기라는 단어에 대해서 뜯어보자
고등학교 때 언어 영역이나 외국어 영역을 공부할 때 `지문 안에 답이 있다`라는 말을 들어본 적이 있을 것이다. 공학이나 과학 분야에서 사용되는 용어는 주로 영어에서 파생되었고, 이를 한국어로 번역하는 과정에서 오히려 뜻을 알기가 어려운 단어로 번역되는 경우가 있긴 하지만, 대부분의 경우에는 이 단어를 뜯어보면 어느 정도 의미를 유추할 수 있다.

갑자기 분위기가 외국어 영역이 된 것 같지만, 필자는 개인적으로 이런 과정 또한 중요하다고 생각한다. 이 과정을 통해 우리가 기존에 알고 있는 `동기화`라는 단어에서 동기의 뜻과 컴퓨터 공학에서 사용하는 동기의 뜻이 왜 다른 지를 이해할 수 있기 때문이다.

<center>
  {% asset_img memorize.jpg 350 %}
  <small>필자는 개인적으로 암기보다는 이해를 지향하는 편이다</small>
  <br>
</center>

`동기(同期)`라는 단어의 한자를 보면 `같을 동(同)`, `기약할 기(期)`를 사용하고 있으며, 일반적으로 우리가 입사 동기, 군대 동기 등을 이야기 할 때 쓰는 동기와 같은 단어다. 이 단어는 `같은 기간` 또는 `같은 주기`라는 뜻을 가지고 있다. 만약 `이 두 시스템은 동기처리시스템이다`라고 하면 이 두 시스템이 같은 주기를 공유하는 처리 프로세스를 가진다는 의미인 것이다.

그래서 일반적으로 사람들이 동기라는 단어를 설명할 때 `동시에 발생하는 것`으로 이야기하는 것이다. 하지만 앞서 말했듯이 우리가 일반적으로 사용하는 `동기화`라는 단어의 용법 때문에 사람을 굉장히 혼란스럽게 만든다.

우리가 아이폰과 아이튠즈를 동기화하는 것이 이 두 대상의 주기를 같게 맞추는 것이 아니기 때문이다. 게다가 일반적으로 한국어에서 `~화`라고 함은 앞에 붙은 단어의 의미를 그대로 가져가는 경우가 많아서 더 헷갈린다.

그러나 영어는 다르다. 영어는 비슷해 보이는 단어라도 단순히 어원이 가지고 있는 추상적인 의미만을 공유하는 경우가 많기 때문에 거시적인 뜻은 비슷하더라도 세부적으로는 조금 다른 뉘앙스의 뜻을 가지고 있는 경우가 존재한다. 일단 동기화를 뜻하는 `Synchronization`과 컴퓨터 공학에서 동기를 의미하는 `Synchronous`의 어원인 `Syn-`의 사전적 의미를 한번 살펴보자.

{% blockquote Webster https://www.merriam-webster.com/dictionary/syn- %}
**syn-** <small>[prefix]</small>
1. : with : along with : together
2. : at the same time
{% endblockquote %}

한글의 동기화와 동기의 관계와 다르게 `Synchronization`과 `Synchronous`의 어원인 `Syn-`은 굉장히 포괄적인 의미라는 것을 알 수 있다. 한국어로 하면 `동기`라는 뜻이 명확한 글자가 중복되기 때문에 비슷한 무언가로 생각할 수 있지만, 영어로 바꿔보면 이 둘은 전혀 다른 의미를 가질 수 있다는 것이다.

그래서 결국 Synchronization와 Synchronous 두 단어 모두 `무언가 동일하게 한다`라는 추상적인 느낌으로 사용되고 있고 대부분의 경우 동일하게 맞춰야 하는 대상이 시간 또는 행위가 되는 것이다. 그래서 아이폰과 아이튠즈 간의 동기화는 `행위`에 초점을 맞추는 것이고 컴퓨터 공학에서 사용하는 동기는 `시간`에 초점을 맞춘다고 보면 된다.

심지어 `Syn-`은 단순히 `Together`라는 의미를 내포하는 단어이기 때문에 이런 상황에서도 사용할 수 있다.

{% blockquote %}
He and I are **out of sync** in everything
그와 나는 모든 면에서 **맞지 않는다**
{% endblockquote %}

여기서는 `out of sync`가 `맞지 않는다`라는 의미를 가지고 있다. 그래서 우리가 이 단어를 여러가지 상황에 맞춰서 사용하는 것이고, 이런 특성 때문에 이 단어를 일반적으로 사용하는 케이스와 컴퓨터 공학에서 사용하는 케이스의 간극이 발생하는 것이다. 사실 한국어의 `동기`라는 의미에만 초점을 맞추면 이 두 단어 간의 공통점을 연상하기가 쉽지 않은 것 같다.

### 컴퓨터 공학에서의 동기와 비동기
자, 여기까지는 `동기(Synchronous)`가 우리가 생각했던 것보다 좀 더 추상적인 의미들을 내포하고 있다는 것을 알아봤다. 그럼 이제 컴퓨터 공학에서 사용되는 동기의 의미에 대해서 알아보도록 하자.

필자는 동기와 비동기가 `프로세스간 커뮤니케이션에 대한 매커니즘`이라고 이야기 했다. 우리는 여기서 `커뮤니케이션`이라는 단어에 집중해야한다. 일반적으로 여기서 이야기하는 커뮤니케이션이란 대충 이런 느낌이다.

```js
function test (number) {
  if (typeof number !== 'number') {
    return;
  }
  return number + 1;
}

console.log(test(1)); // 2
```

만약 이런 코드가 있다면 우리는 `test` 함수를 호출했을 때 이 친구의 내부 로직이 모두 실행을 마치고 다시 값을 반환해주는 것을 기대한다. 이후 `test` 함수의 실행이 모두 끝났다면 우리는 예외처리에 걸려 `undefined`가 반환되든, 제대로 계산이 되어서 `2`가 반환되든간에 `test` 함수의 실행 결과를 받아볼 수 있다.

즉, 우리는 메인 컨텍스트가 `test` 함수에게 실행을 지시했고 `test` 함수가 자신의 수행 결과를 반환함으로서 다시 메인 컨텍스트에게 응답했다고 볼 수 있는 것이다. 필자는 이해를 돕기위해 우리에게 익숙한 코드 레벨에서의 상황을 예로 들었으니 `메인 컨텍스트`와 `함수`의 관계로 설명했지만, 네트워크 모델에서는 `클라이언트`와 `서버`가 될 것이고, I/O 모델에서는 `어플리케이션`과 `커널`이 될 것이다.

쉽게 이야기해서 `일을 시킨 놈`과 `일을 하는 놈`이 있으면 그 어디에도 적용할 수 있는 개념이다. 동기와 비동기의 차이는 바로 이 커뮤니케이션이 어떤 방식으로 이루어지고, 작업의 종료를 알아내는 주체가 누구냐에 따라 나누어지는 것이다.

`동기` 방식을 사용하면 호출당한 함수가 자신의 수행이 모두 끝나서 결과를 냈다는 사실을 스스로 알려주지 않는다. 실행을 지시한 주체가 직접 작업이 종료되었는지 여부를 알아내야 한다는 것이다.

반대로 `비동기` 방식은 `fire and forget`이다. 실행을 지시하고나면 그 다음에 일이 어떻게 되든 나몰라라하는 방식인 것이다. 그 이후 호출당한 함수가 자신의 작업이 종료되면 자신을 호출한 주체에게 그 사실을 알려준다.

그런 의미에서 `동기 & 비동기`를 프로세스간 커뮤니케이션에 대한 매커니즘이라고 이야기하는 것이다.






