---
title: 동기와 비동기에 대해서
toc: true
widgets:
  - type: toc
    position: right
  - type: category
    position: right
sidebar:
  right:
    sticky: true
tags:
categories:
thumbnail:
---

이번 포스팅에서는 I/O와 네트워크 등 전반적으로 다양한 모델에서 사용하는 개념인 `동기(Synchronous)와 비동기(Asynchronous)`에 대해서 한번 이야기 해보려고 한다. 그리고 이 두가지 개념과 많이 혼동되는 개념인 `블록킹(Blocking)과 논블록킹(Non-Blocking)`에 대해서도 간단하게 한번 짚고 넘어갈 예정이다.

<!-- more -->

본격적인 포스팅에 들어가기에 앞서 한가지 확실하게 이야기하고 싶은 것은 동기와 비동기는 `프로세스간 커뮤니케이션에 대한 매커니즘`이고 블록킹과 논블록킹은 `프로그램의 제어권에 대한 개념`으로 사실은 별개의 개념이라는 것이다.

많은 분들이 `동기와 블록킹`, `비동기와 논블록킹`이 같은 것, 혹은 비슷한 것으로 오해하고 있는데, 방금 이야기 했듯이 이 두가지 개념은 서로 전혀 다른 곳에 초점을 맞춘 개념들이므로 서로 직접적인 관련이 없다고 봐도 된다.

이미 많은 능력자 분들이 이 주제에 대해서 잘 정리해놓은 포스팅들이 있지만, 대부분 이 개념들을 묶어서 다루고 있기 때문에, 이 개념들을 처음 접하거나 컴퓨터 공학에 대한 이해가 없는 사람은 이 두 가지 개념들이 서로 뭔가 연관이 있는 것으로 오해하기 쉽다. 많은 포스팅에서 이 주제들을 묶어서 다루는 이유는 이 개념들을 구현한 구현체에서 이 두가지 개념이 함께 사용되기 때문이다.

<center>
  {% asset_img 4elements.png 500 %}
  <small>보통 이런 그림을 가지고 와서 많이 설명한다</small>
  <br>
</center>

일반적으로 `동기 & 블록킹`, `동기 & 논블록킹`, `비동기 & 블록킹`, `비동기 & 논블록킹`과 같이 조합해서 사용하였을때 그 구현체가 어떤 방식으로 작동하는지를 설명하게 되는데, 필자는 개인적으로 이렇게 묶어서 접근하는 것보다는 우선 각각 개념을 이해한 다음에 이 조합들에 대해서 공부하는 것이 이해가 더 잘될 것이라고 생각한다.

그리고 이 개념들에 대한 예시로 대부분 I/O 작업 시 어플리케이션과 커널의 통신을 예로 드는 경우가 많은데, 사실 이 개념 자체는 I/O든 네트워크든 코드를 해석하는 엔진이든 다 동일하게 사용하기 때문에 필자는 개발자들이 좀 더 직관적으로 이해하기 쉬운 코드를 예시로 들어 설명할 것이다.

그래서 이번 포스팅에서는 이 각각의 용어가 정확히 무엇을 의미하는지 설명하고 이 4가지 개념이 서로 결합하는 케이스가 어떠한 상황을 의미하는 것인지를 한번 설명해보려고 한다.

## 동기와 비동기부터 알아보자
<center>
  {% asset_img sync_async.jpg 500 %}
  <br>
</center>

`동기(Synchronous)`와 `비동기(Asynchronous)`는 프로세스 또는 함수 간의 커뮤니케이션에 대한 매커니즘을 의미한다. 이 커뮤니케이션을 통해 작업을 시키는 놈과 작업을 하는 놈이 순서대로 종료된다면 `동기` 방식을 사용하는 것이고 그런 순서가 보장되지 않고 종료되면 `비동기`라고 생각하면 된다.<small>(블록 & 논블록은 여기서는 생각하지 않도록 한다)</small>

대부분의 포스팅에서 동기의 의미를 설명할 때 `어떤 사건이 동시에 발생하는 것`으로 설명하고 있다. 그러나 사실 컴퓨터 공학에서의 동기라는 단어가 가지는 의미는 `동일한 주기를 가지는 것`에 더 가깝다. 이 동일한 주기가 프로세스 수행의 순서 보장에 어떤 영향을 끼치는 지는 밑에서 따로 후술하도록 하겠다.

또한 필자는 개인적으로 이 `동기`라는 방식이 잘 와닿지 않는 이유는 단어의 의미가 애매해서라고 생각한다. 사실 `블록킹` 같은 단어는 농구같이 일상에서 접할 수 있는 스포츠에서도 사용하고 있는데다가 `뭔가를 막는다`라는 뜻이 바로 와닿기 때문에 조금 이해하기 쉬운 편이지만 동기는 조금 다르다.

게다가 우리가 일상에서 주로 접하는 동기의 예는 바로 `동기화(Synchronization)`이다. 예를 들면 아이폰에 음악을 넣을 때 아이튠즈에서 사용하는 동기화 기능 같은 것 말이다. 이때 동기화는 `서로 다른 상태를 같은 것으로 만드는 것`을 의미하는데, 컴퓨터 공학에서 사용하는 동기의 의미와는 느낌이 조금 다르다.

그래서 필자는 `동기`라는 단어가 정확히 무엇을 의미하는지부터 한번 이야기해보려고 한다. 왜 동기라는 단어는 이렇게 다양한 해석을 가지는 것일까?

### 동기라는 단어에 대해서 뜯어보자
고등학교 때 언어 영역이나 외국어 영역을 공부할 때 `지문 안에 답이 있다`라는 말을 들어본 적이 있을 것이다. 공학이나 과학 분야에서 사용되는 용어는 주로 영어에서 파생되었고, 이를 한국어로 번역하는 과정에서 오히려 뜻을 알기가 어려운 단어로 번역되는 경우가 있긴 하지만, 대부분의 경우에는 이 단어를 뜯어보면 어느 정도 의미를 유추할 수 있다.

갑자기 분위기가 외국어 영역이 된 것 같지만, 필자는 개인적으로 이런 과정 또한 중요하다고 생각한다. 이 과정을 통해 우리가 기존에 알고 있는 `동기화`라는 단어에서 동기의 뜻과 컴퓨터 공학에서 사용하는 동기의 뜻이 왜 다른 지를 이해할 수 있기 때문이다.

<center>
  {% asset_img memorize.jpg 350 %}
  <small>암기하지말고 이해하자</small>
  <br>
</center>

`동기(同期)`라는 단어의 한자를 보면 `같을 동(同)`, `기약할 기(期)`를 사용하고 있으며, 일반적으로 우리가 입사 동기, 군대 동기 등을 이야기 할 때 쓰는 동기와 같은 단어다. 이 단어는 `같은 기간` 또는 `같은 주기`라는 뜻을 가지고 있다. 만약 `이 두 시스템은 동기처리시스템이다`라고 하면 이 두 시스템이 같은 주기를 공유하는 처리 프로세스를 가진다는 의미인 것이다.

하지만 앞서 말했듯이 우리가 일반적으로 사용하는 `동기화`라는 단어의 용법이 사람을 굉장히 혼란스럽게 만든다. 우리가 아이폰과 아이튠즈를 동기화하는 것이 이 두 대상의 주기를 같게 맞추는 것이 아니기 때문이다. 게다가 일반적으로 한국어에서 `~화`라고 함은 앞에 붙은 단어의 의미를 그대로 가져가는 경우가 많아서 더 헷갈린다.

그러나 영어는 다르다. 영어는 비슷해 보이는 단어라도 단순히 어원이 가지고 있는 추상적인 의미만을 공유하는 경우가 많기 때문에 거시적인 뜻은 비슷하더라도 세부적으로는 조금 다른 뉘앙스의 뜻을 가지고 있는 경우가 존재한다. 일단 동기화를 뜻하는 `Synchronization`과 컴퓨터 공학에서 동기를 의미하는 `Synchronous`의 어원인 `Syn-`의 사전적 의미를 한번 살펴보자.

{% blockquote Webster https://www.merriam-webster.com/dictionary/syn- %}
**syn-** <small>[prefix]</small>
1. : with : along with : together
2. : at the same time
{% endblockquote %}

한글의 동기화와 동기의 관계와 다르게 `Synchronization`과 `Synchronous`의 어원인 `Syn-`은 굉장히 포괄적인 의미라는 것을 알 수 있다. 한국어로 하면 `동기`라는 뜻이 명확한 글자가 중복되기 때문에 비슷한 무언가로 생각할 수 있지만, 영어로 바꿔보면 이 둘은 전혀 다른 의미를 가질 수 있다는 것이다.

그래서 결국 Synchronization와 Synchronous 두 단어 모두 `무언가 동일하게 한다`라는 추상적인 느낌으로 사용되고 있고 대부분의 경우 동일하게 맞춰야 하는 대상이 시간 또는 상태가 되는 것이다. 그래서 아이폰과 아이튠즈 간의 동기화는 `상태(State)`에 초점을 맞추는 것이고 컴퓨터 공학에서 사용하는 동기는 `주기(Period)`에 초점을 맞춘다고 보면 된다.

심지어 `Syn-`은 단순히 `Together`라는 의미를 내포하는 단어이기 때문에 이런 상황에서도 사용할 수 있다.

{% blockquote %}
He and I are **out of sync** in everything
그와 나는 모든 면에서 **맞지 않는다**
{% endblockquote %}

여기서는 `out of sync`가 `맞지 않는다`라는 의미를 가지고 있다. 그래서 우리가 이 단어를 여러가지 상황에 맞춰서 사용하는 것이고, 이런 특성 때문에 이 단어를 일상에서 사용하는 케이스와 컴퓨터 공학에서 사용하는 케이스의 간극이 발생하는 것이다. 사실 한국어의 `동기`라는 의미에만 초점을 맞추면 이 두 단어 간의 공통점을 연상하기가 쉽지 않다.

### 컴퓨터 공학에서의 동기와 비동기
자, 위에서 설명했듯이 `동기(Synchronous)`라는 단어가 `어떤 두 대상의 주기를 맞추는 것`이라는 것을 알아봤다. 그럼 컴퓨터 공학에서 이 `동기`라는 방식이 어떤 원리로 프로세스의 처리 순서를 보장하는지 알아보도록 하자.

필자는 동기와 비동기가 `프로세스간 커뮤니케이션에 대한 매커니즘`이라고 이야기 했다. 우리는 여기서 `커뮤니케이션`이라는 단어에 집중해야한다. 일반적으로 여기서 이야기하는 커뮤니케이션이란 대충 이런 느낌이다.

```js
function test (number) {
  if (typeof number !== 'number') {
    return;
  }
  return number + 1;
}

console.log(test(1)); // 2
```

만약 이런 코드가 있다면 우리는 `test` 함수를 호출했을 때 이 친구의 내부 로직이 모두 실행을 마치고 다시 값을 반환해주는 것을 기대한다. 이후 `test` 함수의 실행이 모두 끝났다면 우리는 예외처리에 걸려 `undefined`가 반환되든, 제대로 계산이 되어서 `2`가 반환되든간에 `test` 함수의 실행 결과를 받아볼 수 있다.

즉, 우리는 메인 컨텍스트가 `test` 함수에게 실행을 지시했고 `test` 함수가 자신의 수행 결과를 반환함으로서 다시 메인 컨텍스트에게 응답했다고 볼 수 있는 것이다. 필자는 이해를 돕기위해 우리에게 익숙한 코드 레벨에서의 상황을 예로 들었으니 `메인 컨텍스트`와 `함수`의 관계로 설명했지만, 네트워크 모델에서는 `클라이언트`와 `서버`가 될 것이고, I/O 모델에서는 `어플리케이션`과 `커널`이 될 것이다.

쉽게 이야기해서 `일을 시킨 놈`과 `일을 하는 놈`이 있으면 그 어디에도 적용할 수 있는 개념이다. 동기와 비동기의 차이는 바로 이 작업의 종료 여부를 어떻게 알아내느냐에 있다.

#### 동기 방식이 작업의 종료를 알아내는 방법
동기 방식에서는 호출당한 친구가 자신의 작업 종료 여부를 따로 알려주지 않는다. 이 친구는 그냥 시킨 일을 할 뿐이고 작업이 진행 중인지 끝났는 지는 일을 시킨 놈이 신경쓰고 있다는 것이다. 한번 간단한 예시를 보도록 하자.

```js
class Worker {
  constructor () {
    this.isFinish = false;
  }

  startWork () {
    console.log('노동자 출근');
    setTimeout(() => {
      this.isFinish = true;
    }, 1000);
  }
}
```

`Worker` 클래스는 `startWork`라고 선언된 노동 메소드를 가지고 있고, 이 메소드는 단순히 1초 후에 `isFinish` 멤버 변수를 `true`로 바꾸는 작업을 수행한다. 코드를 보면 알겠지만 `Worker` 클래스는 자신의 멤버 변수만 변경할 뿐이고 외부로 자신의 작업이 끝났다는 사실을 알려주는 기능은 없다. 그럼 이제 이 노동자에게 일을 시켜보도록 하자.

```js
const worker = new Worker();
worker.startWork();

const checkWorkerStatus = setInterval(() => {
  if (worker.isFinish) {
    console.log('노동자 퇴근');
    console.log('사장님 퇴근');
    clearInterval(checkWorkerStatus);
  }
  else {
    console.log('노동자 근무중');
  }
}, 200);
```

자 이제 사장님이 이 노동자에게 일을 시킨다. 문제는 이 노동자는 자기 작업이 끝났는지 사장님에게 보고를 안해준다는 것이다. 그래서 사장님은 `200ms`마다 주기를 정해서 노동자의 작업이 끝났는 지를 주기적으로 물어보고 있다. 사장님과 노동자는 사장님이 `200ms`의 주기마다 서로 커뮤니케이션을 하고 있는 것이다. 이때 이 일정한 주기를 중심으로 사장님과 노동자가 서로 커뮤니케이션하고 있기 때문에 `동기`, 즉 같은 주기를 가지고 있다고 하는 것이다.

```text
노동자 출근
노동자 근무중
노동자 근무중
노동자 근무중
노동자 근무중
노동자 퇴근
사장님 퇴근
```

그리고 이렇게 동기를 정하게 되면 사장님은 노동자가 퇴근하기 전까지 절대 퇴근할 수 없다는 것을 볼 수 있다. 물론 NodeJS의 이벤트 루프에서 `setInterval`과 `setTimeout`의 실행 타이밍이 다르기 때문에 완벽한 재현이라고 할 수는 없겠지만, 포인트는 사장님이 노동자의 작업 종료 여부를 신경쓰고 있다는 것이다.

이때 사장님이 노동자의 작업 종료 여부를 신경쓰는 와중에 다른 일을 할 수 없다면 `블록킹`, 할 수 있다면 `논블록킹`이라고 할 수 있지만 지금은 일단 사장님이 일을 하냐마냐는 신경쓰지말고 누가 작업의 종료를 신경쓰고 있냐에만 집중하도록 하자. 

#### 비동기 방식이 작업의 종료를 알아내는 방법






