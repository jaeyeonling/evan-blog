---
title: 동기와 비동기에 대해서
toc: true
widgets:
  - type: toc
    position: right
  - type: category
    position: right
sidebar:
  right:
    sticky: true
tags:
categories:
thumbnail:
---

이번 포스팅에서는 I/O와 네트워크 등 전반적으로 다양한 모델에서 사용하는 개념인 `동기(Synchronous)`와 `비동기(Asynchronous)`에 대해서 한번 이야기 해보려고 한다. 그리고 이 두가지 개념과 많이 혼동되는 개념인 `블록킹(Blocking)`과 `논블록킹(Non-Blocking)`에 대해서도 간단하게 한번 짚고 넘어갈 예정이다.

<!-- more -->

본격적인 포스팅에 들어가기에 앞서 한가지 확실하게 이야기하고 싶은 것은 동기와 비동기는 `프로세스의 수행 순서 보장에 대한 매커니즘`이고 블록킹과 논블록킹은 `프로세스의 유휴 상태에 대한 개념`으로 사실은 별개의 개념이라는 것이다.

많은 분들이 `동기와 블록킹`, `비동기와 논블록킹`이 같은 것, 혹은 비슷한 것으로 오해하고 있는데, 방금 이야기 했듯이 이 두가지 개념은 서로 전혀 다른 곳에 초점을 맞춘 개념들이므로 서로 직접적인 관련은 거의 없다고 봐도 된다. 단지 조합해서 사용하는 것 뿐이다.

이미 많은 능력자 분들이 이 주제에 대해서 잘 정리해놓은 포스팅들이 있지만, 대부분 이 개념들을 묶어서 다루고 있기 때문에 이 개념들을 처음 접하거나 컴퓨터 공학에 대해 잘 모르는 사람은 이 두 가지 개념이 서로 뭔가 연관이 있는 것으로 오해하기 쉽다. 많은 포스팅에서 이 주제들을 묶어서 다루는 이유는 이 개념들을 구현한 구현체에서 이 두가지 개념이 함께 사용되기 때문이다.

<center>
  {% asset_img 4elements.png 500 %}
  <small>보통 이런 그림을 예시로 들면서 많이 설명한다</small>
  <br>
</center>

일반적으로 `동기 & 블록킹`, `동기 & 논블록킹`, `비동기 & 블록킹`, `비동기 & 논블록킹`과 같이 조합해서 사용하였을때 그 구현체가 어떤 방식으로 작동하는지를 설명하기 때문에 필자도 비슷한 방법으로 설명을 진행하겠지만 이 포스팅의 메인 주제는 어디까지나 `동기와 비동기`이다.

그래서 이번 포스팅에서는 이 각각의 용어가 정확히 무엇을 의미하는지 설명하고 이 4가지 개념이 서로 결합하는 케이스가 어떠한 상황을 의미하는 것인지를 한번 설명해보려고 한다.

## 동기와 비동기부터 알아보자
`동기`와 `비동기`는 프로세스 수행 순서 보장에 대한 매커니즘을 의미한다. 간단히 설명하자면 작업들이 순서대로 진행된다면 `동기` 방식을 사용하는 것이고 그런 순서가 보장되지 않고 진행되면 `비동기`라고 생각하면 된다. <small>(블록 & 논블록은 일단 생각하지 않도록 한다)</small>

<center>
  {% asset_img sync_async.jpg 500 %}
  <br>
</center>

필자는 개인적으로 이 `동기`라는 방식이 잘 와닿지 않는 이유는 단어의 의미가 애매해서라고 생각한다. 사실 `블록킹` 같은 단어는 농구같이 일상에서 접할 수 있는 스포츠에서도 사용하고 있는데다가 `뭔가를 막는다`라는 뜻이 바로 와닿기 때문에 조금 이해하기 쉬운 편이지만 동기는 조금 다르다.

우리가 일상에서 주로 접하는 동기의 쓰임새 중 대표적인 예는 `동기화(Synchronization)`이다. 아이폰에 음악을 넣을 때 아이튠즈에서 사용하는 동기화 기능 같은 것 말이다.

이때 동기화는 `서로 다른 상태를 같은 것으로 만드는 것`을 의미하는데, 물론 `데이터베이스 동기화`와 같이 동일한 의미로 사용되는 경우도 있지만 대부분 `동기 & 비동기` 키워드를 통해 설명하는 동기는 `동시에 발생하는 것`이라고 설명하고 있기 때문에 느낌이 조금 다르다.

그래서 필자는 `동기`라는 단어가 정확히 무엇을 의미하는지부터 한번 이야기해보려고 한다. 왜 동기는 이렇게 다양한 해석을 가지는 것일까?

### 동기라는 단어의 의미
고등학교 때 언어 영역이나 외국어 영역을 공부할 때 `지문 안에 답이 있다`라는 말을 들어본 적이 있을 것이다. 공학이나 과학 분야에서 사용되는 용어는 주로 영어에서 파생되었고, 이를 한국어로 번역하는 과정에서 오히려 뜻을 알기가 어려운 단어로 번역되는 경우가 있기 때문에 원본인 영어 단어의 뜻을 제대로 파악하는 것이 중요하다.

갑자기 분위기가 외국어 영역이 된 것 같지만, 필자는 개인적으로 이런 과정 또한 중요하다고 생각한다. 이 과정을 통해 우리가 기존에 알고 있는 `동기화`라는 단어에서 동기의 뜻과 컴퓨터 공학에서 사용하는 동기의 뜻이 왜 다른지를 이해할 수 있기 때문이다.

<center>
  {% asset_img memorize.jpg 350 %}
  <small>암기하지말고 이해하자</small>
  <br>
</center>

`동기(同期)`라는 단어의 한자를 보면 `같을 동(同)`, `기약할 기(期)`를 사용하고 있으며, 일반적으로 우리가 입사 동기, 군대 동기 등을 이야기 할 때 쓰는 동기와 같은 단어다. 이 단어는 `같은 기간` 또는 `같은 주기`라는 뜻이다. 역시 우리가 일반적으로 상태를 통일시킨다는 의미로 사용하는 동기화의 의미랑은 조금 다른 것 같다.

우리가 아이폰과 아이튠즈를 동기화하는 것이 이 두 대상의 기간이나 주기를 같게 맞추는 것은 아니지 않은가? 게다가 일반적으로 한국어에서 `~화`라고 함은 앞에 붙은 단어의 의미를 그대로 가져가는 경우가 많아서 더 헷갈린다.

하지만 사실 우리가 동기의 번역으로 많이 사용하는 `Synchronous`는 살짝 다른 뉘앙스를 가지고 있다.

{% blockquote Webster https://www.merriam-webster.com/dictionary/synchronous %}
**synchronous** <small>[adjective]</small>
: happening, existing, or arising at precisely the same time
{% endblockquote %}

자, 일단 Synchronous는 동기와 다르게 형용사다. 그래서 사실 한국어로 정확히 번역하면 `동기적인`과 같은 뜻이 되어야 하지만, 한국어로 형용사를 단독으로 사용하는 경우는 별로 없기 때문에 그냥 편의상 명사로 번역하는 것 같다. 그러나 이런 과정에서 바로 한국어 단어와 영어 단어의 뉘앙스가 달라지는 경우가 발생한다.

그리고 의미를 보면 `정확히 같은 시간에 발생, 존재하는 것`이라고 한다. 그리고 이 단어는 형용사이기 때문에 `무엇`이 정확하게 같은 시간에 발생하는지는 적혀있지 않다. 그럼 이제 동기화를 의미하는 `Synchronization`의 사전적 의미를 한번 살펴보자.

{% blockquote Webster https://www.merriam-webster.com/dictionary/synchronization %}
**synchronization**
: the state of being synchronous
{% endblockquote %}

Synchronization은 `Synchronous한 상태`라고 한다. 즉, 동기와 동기화는 근본적으로 같은 뜻이라는 말이다. 같은 단어를 공유하는 이 두 단어가 다른 뜻이 되는 것은 영어를 한글로 번역하는 과정에서 영어 특유의 뉘앙스를 제대로 표현하기가 어렵기 때문에 발생하는 문제이다.

게다가 이 단어들의 원형인 `Synchro`는 단어 자체가 뜻을 의미하는 변태적인 단어이기 때문에 한글로 번역하기도 쉽지 않다.<small>(한국어로 치면 "애매하다"같은 느낌이다. 이런건 반대로 영어로 번역하기 쉽지 않다.)</small>

Synchronize, Synchronization, Synchronous 등 많은 단어가 있지만 이 단어들이 공통적으로 가지는 뉘앙스는 바로 `동시에 똑같이 진행되는 느낌`이다. 그것이 상태이든 동작이든 사건이든 동시에 똑같이 진행되는 느낌을 말하는 것이다.

<center>
  {% asset_img synchronized-swimming.jpg 500 %}
  <small>대표적인 싱크로의 예</small>
  <br>
</center>

즉, 아이폰과 아이튠즈의 상태를 동일하게 만드는 것은 `작업이 끝남과 동시에 아이폰과 아이튠즈가 같은 상태`가 되므로 Synchro가 맞은 것이고, 일반적으로 컴퓨터 공학에서 이야기하는 동기의 해석인 `동시에 발생하는 사건` 또한 Synchro가 맞은 것이라고 할 수 있는 것이다.

심지어 이 단어들의 프리픽스인 `Syn-`은 단순히 `Together`라는 의미를 내포하는 단어이기 때문에 이런 상황에서도 사용할 수 있다.

{% blockquote %}
He and I are **out of sync** in everything
그와 나는 모든 면에서 **맞지 않는다**
{% endblockquote %}

이렇게 한국어로 직역하기 어려운 단어는 뉘앙스를 통해서 뜻을 이해하는 편이 더 좋다. 교수님들이나 과학자들이 한국말하는 중간에 영어 단어를 섞어서 사용하는 것은 이런 이유도 있다고 생각한다. 사실 한국어의 `동기`라는 의미에만 초점을 맞추면 `Synchro`에서 변형된 단어들 간의 공통점을 연상하기가 쉽지 않다.

### 컴퓨터 공학에서의 동기와 비동기
많은 포스팅에서 동기의 의미를 설명할 때 `현재 작업의 요청과 응답이 동시에 발생하는 것`으로 설명하고 있지만 이 `동시`라는 단어가 가지는 의미와 다르게 요청과 응답 사이에는 일정한 시간이 존재할 수 밖에 없기 때문에 뭔가 모순이 느껴진다. 하지만 사실 동시에 발생하는 것은 현재 작업의 요청과 응답이 아니라 `현재 작업의 응답과 다음 작업의 요청`이다.

<center>
  {% asset_img sync.jpg 500 %}
  <small>동기 방식은 현재 작업의 응답과 다음 작업의 요청의 타이밍을 맞추는 방식이다</small>
  <br>
</center>

즉, 현재 작업의 응답이 발생함과 동시에 다음 작업을 요청한다는 것은 작업이 어떠한 순서를 가지고 진행된다는 것을 의미한다. 이 응답이라는 것은 사실 귀에 붙히면 귀걸이, 코에 붙히면 코걸이로 네트워크 모델에서는 서버의 응답일 수도 있고 프로세스 모델에서는 제어권의 반납일 수도 있다. 우리가 가장 흔하게 접할 수 있는 동기 방식의 예를 한번 보자.

```js
function attachEyes () {
  for (let i = 1; i < 101; i++) {
    console.log(`인형 눈알 붙히기 ${i}번 수행`);
  }
}
function work () {
  console.log('출근');
  attachEyes();
  console.log('퇴근');
}
work();
```
```text
출근
인형 눈알 붙히기 1번 수행
인형 눈알 붙히기 2번 수행
...
인형 눈알 붙히기 100번 수행
퇴근
```

이 코드를 보면 우리는 자연스럽게 이 작업들이 순서를 가지고 진행될 것이라는 것을 알 수 있다. 내부적으로는 하나의 콜 스택에 작업을 넣고 `Last In First Out`으로 진행되기 때문이라는 것을 알고 있지만, 여기서는 그런 내부 로직보다는 그냥 작업이 순서대로 진행될 것이라는 것에만 집중하자.

<center>
  {% asset_img sync-block.jpg %}
  <small>모든 인형의 눈알을 다 붙히기 전까지 퇴근은 없다</small>
  <br>
</center>

`work` 함수는 출근 작업을 수행한 뒤 `attachEyes` 함수에게 인형 눈알 붙히기 작업을 요청하고 있고, 이 인형 눈알 붙히기 작업이 완료되고나서야 `work` 함수는 퇴근 작업을 수행한다.

쉽게 말해서 작업을 시킨 놈은 작업을 하는 놈이 종료될 때까지 퇴근할 수 없다는 것이다. 이 예제는 인형 눈알 붙히기 작업을 하는 동안 `work` 함수가 아무 일도 못하기 때문에 `블록킹` 방식이라고도 할 수 있지만, `동기 & 비동기`의 개념에서 중요한 것은 상위 프로세스가 일을 하고 있냐마냐가 중요한 것이 아니다. 작업의 순서만 생각하자.

그렇다면 이 예제에서 동기적인 작업의 흐름을 유지하면서 `attachEyes` 함수가 인형의 눈알을 붙히는 동안 `work` 함수가 다른 일을 할 수도 있을까?

```js
function* attachEyes () {
  for (let i = 1; i < 101; i++) {
    console.log(`인형 눈알 붙히기 ${i}번 수행`);
    yield;
  }
  return;
}

function work () {
  console.log('출근');

  const generator = attachEyes();
  let result = {};

  while (!result.done) {
    result = generator.next();
    console.log(`유튜브 시청...`);
  }

  console.log('퇴근');
}

work();
```
```text
출근
인형 눈알 붙히기 1번 수행
유튜브 시청...
인형 눈알 붙히기 2번 수행
유튜브 시청...
...
인형 눈알 붙히기 100번 수행
유튜브 시청...
퇴근
```

위의 예제를 보면 `work` 함수는 출근한 후 `attachEyes`를 호출하여 인형 눈알 붙히기 작업을 시키고 주기적으로 이 작업이 끝났는지를 검사하고 있다. 그리고 아직 작업이 끝나지 않았다면 자신 또한 `유튜브 시청`을 수행하는 것을 볼 수 있다. 이 코드는 분명히 동기적인 흐름을 가지고 진행하고 있지만 `work` 함수 또한 중간중간 자신의 작업을 수행하고 있으므로 블록킹이 아니라 `논블록킹` 방식을 사용하고 있는 것이다.

<center>
  {% asset_img sync-non-block.jpg %}
  <small>니가 일하는 동안 난 짬짬히 유튜브를 보겠다</small>
  <br>
</center>

이 예제들에서 볼 수 있듯이 `동기`와 `블록킹`은 직접적인 관련이 없다. 동기 방식을 사용하더라도 블록킹 일수도 있고 아닐 수도 있다는 것이다.




