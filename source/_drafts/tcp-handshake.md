---
title: TCP가 연결을 생성하고 종료하는 방법, 핸드쉐이크
toc: true
widgets:
  - type: toc
    position: right
  - type: category
    position: right
sidebar:
  right:
    sticky: true
tags:
categories:
thumbnail:
---

TCP 핸드쉐이크, `tcpdump`와 `netstat`으로 확인하기

<!-- more -->

## TCP는 연결 지향 방식이다.
이렇게 TCP의 헤더를 살펴보면 개괄적인 TCP의 기능들을 살펴보았다. 물론 완전한 이해를 위해서는 TCP의 흐름 제어나 혼잡 제어에 대한 내용도 같이 다루면 좋겠지만, 다들 알다시피 그렇게 되면 내용이 장난아닌지라 이번 포스팅에서는 다루지 않겠다.

대신 이번 포스팅에서는 TCP의 대표적인 특징인 `연결 지향(Connection Oriented)`이라는 키워드에 대해서 이야기해보려고 한다.

연결 지향은 말 그대로 연결되어 있는 상태를 지향한다는 의미이다. 사실 `연결`과 `비연결`은 네트워크를 공부하다보면 여러 번 마주치게 되는 단어인데, 필자는 개인적으로 이 단어들의 의미가 조금 헷갈렸었다.

상식적으로 두 기기가 통신을 하려면 케이블이든 뭐든 연결이 되어있어야 할텐데, 굳이 왜 `연결 지향`과 `비연결 지향`을 나누어 놓은 것인지 이해가 되지 않았기 떄문이다.

이게 헷갈리는 이유는 `물리적인 연결`과 `논리적인 연결`의 차이 때문이다.

우리가 일반적으로 기기와 다른 기기를 연결했다고 할 때 떠올리는 생각은 컴퓨터와 모니터를 연결하거나, USB와 컴퓨터를 연결하는 등의 상황이다. 즉, 기기 간의 `물리적인` 연결이다.

<center>
  {% asset_img physical-connection.png 500 %}
  <small>케이블을 사용하여 두 개의 장치를 물리적으로 연결한다</small>
  <br>
</center>

반면, `연결 지향`이라는 단어에서 사용하고 있는 연결의 의미는 `논리적인 연결(Logical Connection)`을 의미한다. 이때 당연히 여러 개의 기기가 서로 통신을 하기위해서는 물리적인 연결 또한 동반되어야한다.

<center>
  {% asset_img logical-connection.png 500 %}
  <br>
</center>

조금 더 쉽게 이야기해보자면, 두 기기가 서로 `연결되어 있는 상태`를 유지하는 것이다.

전화를 예로 들자면, 전화가 전화선에 연결되어있는 것이 물리적인 연결이고 실제로 다른 전화와 통화를 하고 있는 상황이 논리적인 연결, 즉 `연결되어 있는 상태`인 것이다.

그렇다면 왜 TCP는 이런 연결 상태를 유지하는 걸까? 그 이유는 간단하다.

패킷을 여러 개로 쪼개서 보내는데, 보내는 놈이야 그냥 막 보내면 되겠지만 받는 놈 입장에서는 이 패킷이 누가 보낸거고 순서는 어떻게 되는지, 중간에 유실된 패킷은 없는지 등의 수많은 작업을 해야하기 때문이다.

그렇기 때문에 TCP는 `A와 B의 연결 상태`, `A와 C의 연결 상태` 등 각 기기간의 연결 상태를 따로 구분하고 있는 것이다. 이때 TCP는 상대방과 연결 상태를 만들거나 해제하기 위해 특별한 과정을 거치는데, 이 과정을 `핸드쉐이크(Handshake)`라고 한다.

### 3 Way Handshake
먼저, 연결을 만드는 과정부터 살펴보도록 하자. 연결을 생성할 때 거치는 핸드쉐이크 과정을 `3 Way Handshake`라고 하는데, 3 Way라는 말 그대로 총 3번의 통신 과정을 거친다.

<center>
  {% asset_img 3way-handshake.png 450 %}
  <br>
</center>

이때 클라이언트는 먼저 요청 보낸 쪽, 서버는 요청 받은 쪽이 된다는 점에 주의하자. 일반적으로 우리가 생각하는 브라우저나 모바일 앱과 서버의 고정된 역할 관계가 아니다. 그런 이유로 클라이언트와 서버라는 용어 대신 `Sender, Receiver`나 `Initialator, Receiver`와 같은 용어를 사용하기도 한다.

그럼 한 번 각각의 상태가 어떤 것을 의미하는지, 두 기기가 서로 주고 받고 있는 `SYN`과 `ACK`는 무엇을 의미하는지 살펴보도록 하자.

**CLOSED**
연결이 없는 상태이다.

**LISTEN(서버)**
서버가 연결 요청을 기다리고 있는 상태이다.

이후 클라이언트가 연결 요청을 보내기 전까지 서버는 계속 이 상태로 대기하게 된다. 즉, 적극적으로 상대방에게 대시하지 않는다는 것인데, 그래서 이 상태를 `수동 개방(Passive Open)`이라고 한다.

**SYN_SENT(클라이언트)**
클라이언트가 서버에게 연결 요청을 하면서 랜덤한 숫자인 `시퀀스 번호`를 생성해서 보낸 상태이다. 이제 이 값을 사용하여 계속 새로운 값을 만들고 서로 확인하며 클라이언트와 서버가 `연결 상태`를 확인하게 된다.

이 경우는 클라이언트는 서버에게 적극적으로 연결해달라고 조르는 상황이므로 이 상태를 `능동 개방(Active Open)`이라고 한다.

**SYN_RECV(서버)**
서버가 클라이언트에서 보낸 SYN 패킷을 제대로 받은 상태이다. 이후 서버는 제대로 된 시퀀스 번호를 받았다는 확인의 의미인 `승인 번호(Acknowledgement)` 값을 만들어서 다시 클라이언트로 돌려줘야한다. 이때 승인 번호는 처음 `클라이언트가 보낸 시퀀스 번호 + 1`이 된다.

또한 랜덤한 수로 자신의 시퀀스 번호를 다시 생성하여 함께 클라이언트로 보내준다.

**ESTABLISHED(클라이언트)**
클라이언트는 자신이 처음에 보냈던 시퀀스 번호를 알고 있기 때문에 서버가 보내준 승인 번호, 즉 `내 시퀀스 번호 + 1`을 확인할 수 있다. 자신이 보냈던 시퀀스 번호와 이번에 받은 ACK의 차가 1이라면 제대로 연결이 되었다고 판단하는 것이다.

이후 클라이언트는 연결이 성립되었다고 판단하고 `ESTABLISHED` 상태로 들어가면서, 이번에는 서버가 새롭게 만들어서 보내줬던 시퀀스 번호에 다시 1을 더하여 승인 번호로 다시 서버에게 보내준다.

**ESTABLISHED(서버)**
서버는 자신이 만들어서 보냈던 시퀀스 번호만 알고 있는 상황이다. 클라이언트와 마찬가지로 서버 또한 자신이 보냈던 시퀀스 번호와 이번에 받은 승인 번호의 차가 1이라면 제대로 연결이 되었다고 판단하고 `ESTABLISHED` 상태로 들어가게된다.

### 4 Way Handshake
연결을 생성할 때와 마찬가지로, 연결을 종료할 때도 특정한 과정을 거쳐서 연결을 종료해야한다. 이때 클라이언트와 서버가 총 4번의 통신 과정을 거치기 때문에, 이 과정을 `4 Way Handshake`라고 부른다.

<center>
  {% asset_img 4way-handshake.png 450 %}
  <br>
</center>

이때 `FIN` 패킷은 3 Way Handshake 때와 마찬가지로 시퀀스 번호를 생성해서 상대방에게 승인 번호를 받기위한 패킷이다. 이때 3 Way Handshake와 마찬가지로 클라이언트, 서버는 먼저 연결 종료 요청을 보낸 쪽과 요청을 받은 쪽을 의미한다는 점에 주의하자.

**FIN_WAIT_1(클라이언트)**
연결을 종료하고자 하는 클라이언트가 FIN 패킷을 서버에게 전달하면서 `FIN_WAIT1` 상태가 된다. 이 FIN 패킷에는 랜덤한 수로 `시퀀스 넘버`를 생성해서 담아보낸다.

이때 먼저 적극적으로 연결 종료 요청을 보내는 것이기 때문에 이 상태를 `능동 폐쇄(Active Close)`라고 한다.

**CLOSE_WAIT(서버)**
상대방으로부터 FIN 패킷을 받은 서버는 `클라이언트가 보낸 시퀀스 번호 + 1`로 승인 번호를 만들어서 다시 클라이언트에게 응답해주며 `CLOSE_WAIT` 상태로 들어간다. 이때 서버는 자신이 전송할 데이터가 남아있다면 이어서 계속 전송한 후, 모든 전송이 끝났다면 명시적으로 `close()`와 같은 함수를 호출하여 다음 단계로 넘어갈 것이다.

이때 서버는 상대방으로부터 연결 종료 요청을 받은 후 수동적으로 연결을 종료할 준비를 하기 때문에 이 상태를 `수동 폐쇄(Passive Close)`라고 한다.

**FIN_WAIT_2(클라이언트)**
클라이언트는 서버로부터 승인 번호를 받고 자신이 보냈던 시퀀스 번호와 승인 번호의 차가 1이 맞는지 확인한다. 하지만 아직 서버 입장에서는 데이터 전송이 끝나지 않았을 수도 있기에 `FIN_WAIT2` 상태로 들어가서 서버가 연결 종료를 허락하는 `FIN` 패킷을 보내줄 때까지 기다린다.

**LAST_ACK(서버)**
서버는 자신이 전송할 데이터가 더 이상 없다면, 연결 종료 요청에 합의한다는 의미로 클라이언트에게 `FIN` 패킷을 보낸다. 이때 서버가 보내는 FIN 패킷에 담기는 시퀀스 넘버는 클라이언트가 보낸 것을 그대로 사용하고 승인 번호는 클라이언트가 보낸 `승인 번호 + 1`을 사용한다. 이후 서버는 `LAST_ACK` 상태로 들어가며 클라이언트가 다시 승인 번호를 보내줄 때까지 대기한다.

**TIME_WAIT**
서버가 보낸 FIN 패킷을 받은 클라이언트는 다시 `서버가 보낸 시퀀스 번호 + 1`로 승인 번호를 생성하여 서버에 ACK 패킷으로 응답한다. 이후 클라이언트는 `TIME_WAIT` 상태로 들어가며, 의도하지 않은 에러로 인해 연결이 `교착 상태(Deadlock)`에 빠지는 것을 방지한다.

이 값은 `2 MSL(Maximum Segement Lifetime)`으로 정의되어 있으며, 정확한 MSL의 시간 값은 커널에 상수로 정의되어있다.

```bash
$ sysctl net.inet.tcp | grep msl
net.inet.tcp.msl: 15000
```

**CLOSED(서버)**
클라이언트가 보낸 ACK 패킷을 받은 서버는 `CLOSED` 상태로 들어가며 연결을 완전히 종료한다.

**CLOSED(클라이언트)**
`TIME_WAIT` 상태에서 일정 시간이 지나면 클라이언트도 `CLOSED` 상태로 변경된다.