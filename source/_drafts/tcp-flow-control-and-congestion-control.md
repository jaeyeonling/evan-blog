---
title: 패킷의 흐름을 제어하는 TCP
toc: true
widgets:
  - type: toc
    position: right
  - type: category
    position: right
sidebar:
  right:
    sticky: true
tags:
categories:
thumbnail:
---

`TCP(Transmission Control Protocol)`은 이름 그대로 전송을 제어하는 프로토콜로써, 전송을 제어하기 위한 흐름 제어와 혼잡 제어 등의 기능을 프로토콜 자체에 포함하고 있다.

<!-- more -->

이번 포스팅에서는 TCP 시리즈 중 `흐름 제어`, `혼잡 제어`, `오류 제어`에 대한 내용을 이야기해보려고 한다.

## TCP의 흐름 제어
송신 측과 수신 측이 서로 데이터를 주고 받을 때, 여러가지 요인에 따라 이 두 친구들의 처리 속도가 달라질 수 있다. 이때 데이터를 받는 수신 측의 처리 속도가 송신 측보다 빠른 경우는 사실 별 문제가 없다.

주는 족족 빠르게 처리해주니 딱히 문제될 것이 없는 것이다. 그러나 수신 측의 처리 속도보다 송신 측이 더 빠른 경우 문제가 생긴다.

송신 측과 수신 측은 모두 데이터를 저장할 수 있는 버퍼를 가지고 있다. 이때 수신 측이 자신의 버퍼 안에 있는 데이터를 처리하는 속도보다 송신 측이 데이터를 전송하는 속도가 더 빠르다면, 당연히 수신 측의 버퍼는 언젠가 꽉 차버릴 것이기 때문이다.

수신 측의 버퍼가 꽉 찬 상태에서 도착한 패킷은 더 이상 담아둘 공간이 없기 때문에 폐기 처분된다. 물론 이런 상황에서는 송신 측이 다시 패킷을 보내주기는 하겠지만, 패킷을 재전송하는 과정이 다시 동반되어야하기 때문에 사실 상 리소스 낭비라고 볼 수 있다.

그래서 송신 측은 수신 측의 데이터 처리 속도를 파악하고 자신이 얼마나 빠르게, 많은 데이터를 전송할 지 결정해야한다. 이것이 바로 TCP의 흐름 제어인 것이다.

수신 측은 자신이 처리할 수 있는 데이터의 양을 의미하는 `윈도우 크기(Window Size)`를 자신의 응답 헤더에 담아서 송신 측에게 전해주게 되고, 송신 측은 상대방에게 데이터를 보낼 때 이 윈도우 크기를 참고해서 알맞은 양의 데이터를 보냄으로써 전체적인 데이터의 흐름을 제어하게 된다.

### Stop and Wait
`Stop and Wait` 방식은 이름 그대로 상대방에게 데이터를 보낸 후 잘 받았다는 응답이 올 때까지 기다리는 모든 방식을 통칭하는 말이다. 이때 데이터를 받는 수신 측은 `잘 받았어!`와 `못 받았어...` 등의 대답을 해주게 되는데, 수신 측이 어떤 대답을 해주냐에 따라 사용할 수 있는 오류 제어 방법이 나눠지기도 한다.

<center>
  {% asset_img stop-and-wait.png 500 %}
  <br>
</center>

Stop and Wait로 흐름 제어를 할 경우의 대원칙은 단순히 `상대방이 응답을 하면 데이터를 보낸다`이기 때문에 구현 자체도 간단하고 프로그래머가 어플리케이션의 작동 원리를 파악하기도 쉬운 편이다.

기본적인 `ARQ(Automatic Repeat Request)`를 구현한다고 생각해보면, 수신 측의 윈도우 크기를 1 byte로 설정하고 `처리 가능 = 1`, `처리 불가능 = 0`과 같은 식으로 대충 구현해도 돌아가기는 하기 때문이다.

하지만 서로 `처리 가능`, `처리 불가능` 정도의 의미만 주고받는 방식은 간단한만큼 비효율적이라고 할 수도 있다.

즉, 송신 측은 수신 측이 어느 정도의 크기의 버퍼를 가지고 있는지, 처리 능력이 얼마나 되는지 전혀 모르는 상태이기 때문에 항상 전송을 시도해봐야 수신 측이 이 데이터를 처리할 수 있을지 없을지 알 수 있기 때문이다.

그런 이유로 Stop and Wait 방식을 사용하여 흐름 제어를 할 경우에는, 이런 비효율성을 커버하기 위해 이런 단순한 구현이 아닌 여러가지 오류 제어 방식을 함께 도입해서 사용한다.

### Sliding Window
`슬라이딩 윈도우(Sliding Window)`는 수신 측이 한 번에 처리할 수 있는 데이터를 정해놓고 그때그때 수신 측의 데이터 처리 상황을 송신 측에 알려줘서 데이터의 흐름을 제어하는 방식이다.

Stop and Wait과 여러 가지 차이점이 있겠지만, 사실 가장 큰 차이점은 송신 측이 `수신 측이 처리할 수 있는 데이터의 양`을 알고 있다는 점이다. 이 정보를 알고 있기 때문에 굳이 수신 측이 `처리 가능`이라는 대답을 일일히 해주지 않아도 어느 정도 예측이 가능하다는 말이다.

송신 측과 수신 측은 각각 데이터를 담을 수 있는 버퍼를 가지고 있고, 별도로 `윈도우`라는 일종의 마스킹 도구를 가지고 있다. 이때 송신 측은 이 윈도우에 들어있는 데이터를 수신 측의 응답이 없어도 보낼 수 있다.

<center>
  {% asset_img window.png 500 %}
  <small>윈도우 안에 들어있는 프레임은 수신 측의 응답이 없이도 연속으로 보낼 수 있다</small>
  <br>
</center>

송신 측의 윈도우 크기는 맨 처음 TCP의 연결을 생성하는 과정인 3 Way Handshake 때 결정된다.

핸드쉐이크 과정에서 ACK 응답을 하는 수신 측이 송신 측에게 자신의 윈도우 크기를 헤더에 담아서 알려주면, 송신 측은 수신 측이 보내준 윈도우 크기와 자신이 SYN 패킷을 보냈을 때 상대방이 ACK 응답을 보냈던 시간 차를 사용하여 자신의 윈도우 크기를 결정한다.

즉, 송신 측의 윈도우 크기는 수신 측의 처리 속도와 네트워크 환경에 따라 유연하게 설정된다. 수신 측의 처리 속도가 빠를 수록 송신 측의 윈도우 크기도 커지고, 수신 측의 처리 속도가 느릴 수록 송신 측의 윈도우 크기도 줄어드는 것이다.

이때 정해진 윈도우 크기는 고정이 아니라 통신을 하는 과정 중간에도 계속 네트워크의 혼잡 환경과 수신 측이 보내주는 윈도우 크기를 통해 동적으로 변경될 수 있다. 이렇게 윈도우의 크기를 정하고 나면 그 다음부터 이 윈도우를 사용하여 유연하게 흐름 제어를 할 수 있다.

윈도우에 대해 대략적으로 이해를 했다면 이제 이 기법을 왜 `슬라이딩 윈도우`라고 하는 지 한번 살펴보도록 하자.

먼저, 송신 측이 `0 ~ 6`번의 시퀀스 번호를 가진 데이터를 상대방에게 전송하고 싶어하는 상황을 상상해보자. 이때 송신 측의 버퍼에는 전송해야할 데이터들이 이렇게 담겨져 있을 것이다.

<center>
  {% asset_img sw-0.png 500 %}
  <br>
</center>

이때 송신 측은 수신 측에게 받은 윈도우 크기와 현재 네트워크 상황을 고려하여 윈도우 크기를 3으로 잡았고, 윈도우 안에 있는 데이터를 우선 주르륵 전송한다.

<center>
  {% asset_img sw-1.png 500 %}
  <br>
</center>

이때 윈도우 안에 들어있는 데이터는 어떤 상태일까? 일단 데이터를 전송하기는 했지만 아직 수신 측으로부터 잘 받았다는 응답을 받지 못한 상태일 것이다.

즉, 윈도우에 들어있는 데이터들은 항상 `전송은 했지만, 상대방이 처리했는지는 모르는 상태`라고 할 수 있다.

이후 수신 측은 자신의 처리 속도에 맞게 데이터를 처리한 후 응답으로 현재 자신의 버퍼에 남아있는 공간의 크기를 알려준다. 만약 수신 측이 응답으로 `Window Size: 1`을 보냈다면 "내 버퍼 공간이 1 byte만큼 남았으니까 그 만큼만 더 보내봐"라는 의미가 된다.

이제 송신 측은 자신이 데이터 한 개를 더 보낼 수 있다는 사실을 알았으니, 자신의 윈도우를 한 칸 옆으로 밀고 새롭게 윈도우에 들어온 3번 데이터를 수신 측에게 전송한다.

<center>
  {% asset_img sw-2.png 500 %}
  <br>
</center>

이때 윈도우를 옆으로 이동시키며 새로 들어온 데이터를 전송하기 때문에 `슬라이딩 윈도우`라고 하는 것이다. 만약 수신 측이 윈도우 크기를 1이 아니라 더 큰 수를 보냈다면, 송신 측은 그 만큼 윈도우를 옆으로 밀고 더 많은 데이터를 연속적으로 전송할 수 있을 것이다.

단, 이 경우 송신 측의 윈도우 크기가 3이기 때문에 수신 측이 4를 보냈다고 해서 4칸을 밀지는 않고, 자신의 윈도우 크기인 3만큼만 밀 수 있다.

이렇게 데이터를 전송하는 수신 측의 버퍼는 대략 3가지 상태로 나눠질 수 있다.

<center>
  {% asset_img sw-3.png 500 %}
  <br>
</center>

이게 지금 `0 ~ 6` 밖에 안되는 단순화된 그림으로 봐서 잘 와닿지 않을 수도 있지만, 아무런 옵션도 적용하지 않은 TCP의 최대 윈도우 크기는 `65,535 bytes`이고, 연속적으로 한번에 보내는 데이터도 이렇게 한 개, 두 개 정도가 아니라 몇 백 바이트 단위로 보내는 경우가 많다.

즉, 이론적으로는 수신 측의 ACK 응답 없이도 최대 65,535 bytes를 연속적으로 전송할 수 있다는 말이 된다.

Stop and Wait가 일일히 하나 보내고, 응답 받고 하는 것과 비교해보면 확실히 전송 속도 측면에서 빠르기도 하고, 송신 측과 수신 측의 지속적인 커뮤니케이션을 통해 윈도우 크기 또한 유연하게 조절할 수 있기 때문에 Stop and Wait 방식보다 구현은 조금 복잡해도 효율이 좋은 편이다.


## TCP의 오류 제어

### ARQ

#### Stop and Wait

#### Go Back N

#### Selective Repeat

## TCP의 혼잡 제어

### AIMD

### Slow Start

### Congestion Avoidance

### Fast Recovery

### TCP Reno

### TCP Tahoe


