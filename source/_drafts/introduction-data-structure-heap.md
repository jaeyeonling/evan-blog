---
title: 힙을 한번 부셔보자(가제)
toc: true
widgets:
  - type: toc
    position: right
  - type: category
    position: right
sidebar:
  right:
    sticky: true
tags:
categories:
thumbnail:
---

이전의 포스팅에서 몇 번 언급한 적이 있지만 필자는 지금 백수다. 이제 프라하에서 한 달간의 힐링도 끝났으니 슬슬 면접을 보러 다녀야 하는데, 면접에서는 알고리즘이나 자료구조에 대한 질문이 들어올 확률이 굉장히 높다. 그래서 일단은 자료구조부터 다시 살펴볼 생각인데, 그 중 제일 기억이 잘 나지 않는 `힙(Heap)`부터 한번 부셔볼까 한다.

<!-- more -->

## 힙의 구조
힙의 사전적 의미는 `차곡차곡 쌓아올려진 더미`이다. 뭔가 규칙을 가지고 쌓아올려진 
힙은 기본적으로 `완전 이진 트리(Complete Binary Tree)`를 기본으로 한 자료구조이며, 부모 노드와 자식 노드 간의 대소관계가 성립한다. 그렇기 때문에 힙의 루트 노드는 힙 내의 데이터들 중 `가장 큰 값`이거나 `가장 작은 값`이라고 할 수 있다.

<center>
  {% asset_img min-max-heap.png 500 %}
  <br>
</center>

즉, 힙 내의 가장 큰 값이나 가장 작은 값에 한번에 접근할 수 있다는 의미이며, 이 접근 연산의 시간 복잡도는 당연히 $O(1)$이다. 이런 힙의 성격 때문에 힙은 여러 개의 데이터 중에서 가장 크거나 작은 값을 빠르게 찾아야 하는 영역에서 유용하게 사용된다.

### 완전 이진 트리(Complete Binary Tree)
힙의 기본이 되는 완전 이진 트리는 마지막 레벨을 제외한 모든 레벨이 꽉 차 있는 구조를 가지고 있다. 트리는 보통 `링크드 리스트(Linked List)`나 `배열(Array)`와 같은 선형 자료구조를 사용하여 구현하게 되는데, 필자는 개인적으로 완전 이진 트리는 배열로 구현하는 편이 조금 더 효율적이라는 생각이 든다. 완전 이진 트리는 데이터를 트리의 왼쪽부터 채워나가기 때문에 배열 중간에 쓸데없는 메모리 공간의 낭비가 생기지 않기 때문이다.

왜 트리의 왼쪽부터 채워나가는 방법을 사용하면 쓸데없는 메모리의 낭비가 없는 것일까? 먼저 이진 트리의 가장 큰 특징은 다음과 같다.

<center>
  {% asset_img not_allow_new_node.png 500 %}
  <br>
</center>

> 부모 노드는 반드시 2개 이하의 자식 노드를 가져야 한다.

이 말인 즉슨, 중간에 껴 있는 레벨의 노드의 자식 노드가 3개나 4개가 될 일이 없다는 것이고, 노드들에게 고유한 인덱스를 부여할 수 있다는 것을 의미한다. 그리고 트리의 왼쪽부터 데이터가 쌓여진다는 것은, 데이터를 빈 공간 없이 순차적으로 쌓아 나갈 수 있다는 의미이기 때문에 메모리 공간의 낭비가 없다고 하는 것이다.

<center>
  {% asset_img indexed_complete_b_tree.png 500 %}
</center>

***
| Location | 0 | 1 | 2 | 3 | 4 | 5 |
|----------|---|---|---|---|---|---|
| Value    | A | B | C | D | E | F |
***

배열로 구현한 트리의 인덱스는 왼쪽부터 차례대로 부여한다. 만약에 위 그림에서 `C` 노드의 자식 노드인 `F` 노드가 왼쪽이 아닌 오른쪽에 붙어있다면 `5`번 인덱스는 비워놓고 `6`번 인덱스를 사용할 것이다. 그렇다면 5번 인덱스는 그냥 빈 값이 되기 때문에 메모리 공간이 낭비된다.

***
| Location | 0 | 1 | 2 | 3 | 4 | 5 | 6 |
|----------|---|---|---|---|---|---|---|
| Value    | A | B | C | D | E |   | F |
***

하지만 배열은 메모리 공간을 미리 할당해놔야하기 때문에 트리의 최대 크기를 반드시 정해놓고 운용해야한다는 불편한 점이 있긴 하다.
