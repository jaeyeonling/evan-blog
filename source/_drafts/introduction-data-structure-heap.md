---
title: 힙을 한번 부셔보자(가제)
toc: true
widgets:
  - type: toc
    position: right
  - type: category
    position: right
sidebar:
  right:
    sticky: true
tags:
categories:
thumbnail:
---

이전의 포스팅에서 몇 번 언급한 적이 있지만 필자는 지금 백수다. 이제 프라하에서 한 달간의 힐링도 끝났으니 슬슬 면접을 보러 다녀야 하는데, 면접에서는 알고리즘이나 자료구조에 대한 질문이 들어올 확률이 굉장히 높다. 그래서 일단은 자료구조부터 다시 살펴볼 생각인데, 그 중 제일 기억이 잘 나지 않는 `힙(Heap)`부터 한번 부셔볼까 한다.

<!-- more -->

## 힙의 구조
힙은 기본적으로 `완전 이진 트리(Complete Binary Tree)`를 기본으로 한 자료구조이며, 부모 노드와 자식 노드 간의 대소관계가 성립한다. 그렇기 때문에 힙의 루트 노드는 힙 내의 데이터들 중 `가장 큰 값`이거나 `가장 작은 값`이라고 할 수 있다.

<center>
  {% asset_img min-max-heap.png 500 %}
  <br>
</center>

즉, 힙 내의 가장 큰 값이나 가장 작은 값에 접근하고 싶을 때 비교 연산없이 한번에 접근할 수 있다는 의미이며, 이 접근 연산의 시간 복잡도는 당연히 $O(1)$이다. 이런 힙의 성격 때문에 힙은 여러 개의 데이터 중에서 가장 크거나 작은 값을 빠르게 찾아야 하는 영역에서 유용하게 사용된다.

또한 힙은 완전 이진 트리를 기초로 하기 때문에 구현하는 방법 또한 완전 이진 트리와 흡사하다. 그렇기 때문에 힙을 구현해보기에 앞서 완전 이진 트리의 특징을 알고 있어야 한다.

### 완전 이진 트리(Complete Binary Tree)
먼저, 힙의 기본이 되는 완전 이진 트리의 특징을 한번 살펴보자. `이진 트리(Binary Tree)`란 어떤 하나의 노드가 자식 노드를 최대 2개까지만 가질 수 있는 트리를 말한다. 그 말인 즉슨, 한 레벨에 최대로 들어설 수 있는 트리의 개수가 정해져있다는 뜻이고, 노드들에게 고유한 인덱스를 부여할 수 있다는 것을 의미한다.

<center>
  {% asset_img not_allow_new_node.png 500 %}
  <small>부모 노드는 반드시 2개 이하의 자식 노드를 가져야 한다.</small>
  <br>
</center>

`완전 이진 트리(Complete Binary Tree)`는 이진 트리의 노드를 생성할 때 트리의 왼쪽부터 차곡차곡 채워 나가는 트리를 의미한다. 이때 완전 이진 트리의 마지막 레벨을 제외한 모든 레벨은 노드가 꽉 차 있어야 한다.

트리는 보통 `링크드 리스트(Linked List)`나 `배열(Array)`과 같은 선형 자료구조를 사용하여 구현하는데, 이때 링크드 리스트와 배열의 특징에 따라 장단점이 갈리기 때문에 선택이 필요하다.<small>(링크드 리스트와 배열의 차이에 대한 내용은 이 포스팅의 주제가 아니므로 따로 설명하지는 않겠다.)</small>

일반적으로 트리는 링크드 리스트를 사용하여 구현하지만 완전 이진 트리의 경우에는 배열로 구현하는 것이 더 효율적이다.

#### 완전 이진 트리에 배열을 사용하는 이유
사실 트리를 구현할 때 `원소에 한방에 접근이 가능하다`는 배열의 최대 장점을 뒤로 미뤄두고서라도 링크드 리스트를 사용하는 이유는, 배열을 사용하여 트리를 구현하면 불편한 점이 너무 많기 때문이다. 그러나 완전 이진 트리에서는 이 불편한 점들이 사라지기 때문에 배열의 장점을 가져갈 수 있다.

##### 원하는 노드로의 접근이 쉽다
이건 배열의 최대 장점인 `인덱스만 알면 해당 원소에 바로 접근이 가능`하다는 장점을 그대로 살린 것이다. 이진 트리는 각 레벨에 최대로 들어설 수 있는 노드의 개수가 정해져 있기 때문에 간단한 수식만으로 특정 노드의 인덱스를 알아내어 $O(1)$의 시간복잡도로 노드에 접근할 수 있다.

먼저, 특정 노드를 기반으로 부모나 자식 노드에 접근하고 싶다면 다음과 같이 인덱스를 계산해볼 수 있다.

{% blockquote %}
루트 노드가 0번 인덱스를 가지고, 현재 노드가 $i$번 인덱스를 가지고 있을 때

[부모 노드] $(i-1) / 2$
[왼쪽 자식 노드] $2i+1$
[오른쪽 자식 노드] $2i+2$
{% endblockquote %}

위와 같이 특정 노드의 인덱스를 기반으로 부모와 자식들의 인덱스를 알아내는 방법도 있지만, 배열로 만든 완전 이진 트리의 진짜 장점은 간단한 수식을 통해서 원하는 레벨 안의 원하는 순번의 노드로 바로 접근할 수도 있다는 것이다.

완전 이진 트리의 성질을 이용하면 특정 레벨까지의 최대 노드 개수인 $c$를 간단히 계산할 수 있기 때문에 가능한 일이다.

{% math %}
\begin{aligned}
c = 2^{level} - 1
\end{aligned}
{% endmath %}
<br>

```js
function getAllNodeCountByLevel (level = 1) {
  return 2**level - 1;
}

getAllNodeCountByLevel(3) // 7
```

이 식을 사용하면 $n$번째 레벨의 $m$번째 노드의 인덱스도 간단하게 알아낼 수 있다.

예를 들어, 완전 이진 트리의 `n 레벨에 있는 m번째 노드`의 인덱스인 $i$를 구하고 싶다면, 내가 접근하고 싶은 레벨의 바로 위 레벨인 $n - 1$ 레벨까지의 모든 노드의 개수 $c$을 구하고, 거기에 해당 레벨 내에서 내가 $m$번째 노드에 접근하고 싶은지만 더해주면 된다.

{% math %}
\begin{aligned}
i = c + m - 1
\end{aligned}
{% endmath %}
<br>

```js
function getNodeIndex (level = 1, count = 1) {
  return getAllNodeCountByLevel(level - 1) + count - 1;
}

getNodeIndex(3, 3) // 5
```

마지막에 1을 빼주는 이유는 우리가 구하고 싶은 것이 노드의 순번이 아닌 인덱스이기 때문이다. 배열의 인덱스는 `0`부터 시작한다는 사실을 잊지 말자.

이처럼 배열로 구현한 완전 이진 트리는 간단한 계산만으로 원하는 노드에 접근하기가 용이하지만, 링크드 리스트로 구현하게되면 원하는 노드에 바로 접근할 수 없고, 트리를 순회하여 접근해야한다.

##### 배열의 원소를 뒤로 밀어줘야 할 일이 없다
배열은 메모리에 연속적인 공간을 할당하여 사용하기 때문에, 배열 중간에 원소를 끼워넣으려면 새로운 메모리 공간을 확보하기 위해 원소를 한칸씩 뒤로 밀어줘야하는 슬픈 상황이 발생하지만 링크드 리스트는 그냥 `prev` 값과 `next` 값만 변경함으로써 중간에 새로운 원소를 끼워넣기가 편하다.

그러나 이진 트리의 경우, 자식 노드를 최대 2개까지만 가질 수 있다는 제약이 있기 때문에 높이가 $h$인 트리는 최대 노드 개수가 $2^{h} -1$개로 정해져있다. 즉, 이 크기 만큼만 배열을 메모리에 할당하고 나면 중간에 노드를 새로 삽입하기 위해 배열의 원소를 뒤로 밀어야하는 경우가 발생하지 않는다는 것이다.

##### 트리가 기울어지지 않는다
일반적으로 배열로 구현한 트리가 기울어졌을 때 메모리 공간에 낭비가 생기는 이유는 다음과 같다.

<center>
  {% asset_img balanced.jpg 500 %}
</center>

위 그림은 이상적으로 균형이 잡힌 `밸런스드 이진 트리(Balanced Binary Tree)`의 모습이다. 만약 이 트리를 배열로 구현한다면 메모리에는 이렇게 값들이 담길 것이다.

***
| Location | 0 | 1 | 2 | 3 | 4 | 5 |
|----------|---|---|---|---|---|---|
| Value    | A | B | C | D | E | F |
***

배열 중간에 빈 공간이 없이 차곡차곡 메모리에 담겼다. 노드의 인덱스는 트리의 왼쪽부터 순차적으로 부여되기 때문에 자식 노드를 왼쪽부터 생성한다면 메모리에 빈 공간을 만들지 않을 수 있다.

물론 자식 노드를 생성할 때 왼쪽을 건너 뛰고 오른쪽부터 생성하면 빈 공간이 생기긴 하지만, 더 큰 문제는 트리가 한 쪽으로 크게 기울어지게 되게 되는 편향 트리가 되는 경우이다.

<center>
  {% asset_img unbalanced.jpg 500 %}
</center>

***
| Location | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
|----------|---|---|---|---|---|---|---|---|
| Value    | A | B | C | D | - | - | - | H |
***

위 그림처럼 한 쪽으로 크게 기운 편향 트리는 중간 인덱스를 건너뛰고 다음 레벨에 노드를 생성한 경우이기 때문에 메모리에 빈 공간이 생길 수 밖에 없다. 그렇기 때문에 메모리 공간이 낭비된다고 하는 것이다. 물론 오른쪽으로 기울었다면 건너뛰어야 하는 인덱스도 더 크기 때문에 메모리 공간의 낭비가 더 심해진다.

그러나 `완전 이진 트리`는 노드를 왼쪽부터 차곡차곡 채워나가고, 한 레벨의 노드가 다 채워지기 전까지는 다음 레벨에 노드를 채울 수 없다는 제약들이 걸려있기 때문에 애초에 트리가 기울어질 일 자체가 없으니 메모리에 빈 공간이 생길 일도 없다.

이런 이유들로 인해 완전 이진 트리를 기반으로 하는 `힙` 또한 원소에 바로 접근이 가능한 배열의 장점을 살려서 구현하는 경우가 많다.

### 힙의 특징
일단 힙은 완전 이진 트리를 기초로 하기 때문에 