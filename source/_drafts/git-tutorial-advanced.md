---
title: Git 뉴비를 위한 기초 사용법 - 2
toc: true
widgets:
  - type: toc
    position: right
  - type: category
    position: right
sidebar:
  right:
    sticky: true
tags:
  - 튜토리얼
  - Git
  - Tutorial
  - Versioning
  - 협업
  - 버전관리
categories:
  - Methodology
thumbnail:
---

이번 포스팅에서는 저번 포스팅인 {% post_link git-tutorial Git 뉴비를 위한 기초 사용법 %}에서 설명했던 기본적인 명령어보다 좀 더 나아가서 몇가지 개념과 명령어를 더 공부해보려고 한다. 저번 포스팅에서는 리모트 서버에서 소스를 클론하고 수정한 후 다시 리모트 서버에 업데이트하는 과정에 대해 집중해서 설명했다면 이번 포스팅에서는 Git의 메인 주제인 `버전 관리`에 대해 더 다뤄볼 예정이다.
<!-- more -->

그럼 저번 포스팅과 마찬가지로 간단한 용어와 개념에 대한 설명한 후, 그 개념들을 사용하기 위한 명령어를 설명하도록 하겠다.

## 용어와 개념 알아보기
Git은 버전을 효율적으로 관리하기 위해 몇 가지 개념을 제시하고 있다. 현재 나의 버전 상태를 의미하는 `HEAD`, 작업 공간인 `브랜치(Branch)`, 브랜치를 합치는 `머지(Merge)`와 `리베이스(Rebase)`등이 그렇다. 그리고 이런 기능들을 사용하다보면 가끔 Git의 `에러`와 마주하게 되는데, 필자같은 경우는 처음 개발자로 일을 시작했을 때 코딩하다가 발생하는 에러보다 Git에서 발생하는  에러가 더 무서웠던 기억이 있다. 솔직히 코딩하다가 나는 에러는 고치는 과정이 쉽든 어렵든간에 그냥 필자가 고치면 해결되지만, Git에서 나는 에러는 고친답시고 이것 저것 건드리다가 잘못 건드리면 왠지 소스가 가루가 되어 날아갈 것 같아서 무서웠다.

하지만 Git을 사용한 지 6년쯤 지난 지금 다시 그때를 생각해보면 Git에 대해서 잘 몰랐기 때문에 더 무서웠던 것 같다. 내가 어떤 기능을 사용했을 때 소스 버전이 어떻게 되는 지 정확히 알고 있지 않은 상태였기 때문에 그런 걱정도 들었던 것이다. 혹시 이 글을 읽는 독자 분들 중에서도 필자와 같은 경험이나 생각을 하신 분들이 있을 것이기 때문에 필자가 알고 있는 Git의 개념들을 최대한 알기 쉽게 풀어보려고 한다.

그럼 이제 하나하나씩 살펴보도록 하자.

### Merge Conflict
필자 생각에 Git을 사용하다가 가장 많이 마주치는 에러는 아무래도 `머지 컨플릭트(Merge Conflict)`인 것 같다. 에러라고 하기에는 조금 애매하긴 하지만 어쨌든 정상은 아닌 상황이기 때문에 처음 마주하면 굉장히 당황스럽고 뭐가 뭔지 헷갈린다. 컨플릭트는 말 그대로 `소스의 충돌`이 발생한 상황이기 때문에 주니어든 시니어든 가리지 않고 평등하게 발생하고, 또한 평등하게 당황시킨다.

왜냐면 컨플릭트는 논리적인 에러가 아니라 내 작업물과 다른 사람의 작업물이 충돌한 상황이기 때문에 스스로 혼자 해결하기 힘든 경우가 많기 때문이다. 그럼 컨플릭트, 즉 충돌이 정확히 어떤 상황을 말하는 지 알기 위해 실제 협업 상황에서 발생할 수 있는 예시를 함께 살펴보자.

{% blockquote %}
`철수`와 `영희`는 사장님으로부터 지각한 사람의 명단을 만들어서 관리해 달라는 부탁을 받았다. 그래서 철수와 영희는 다음과 같은 `txt` 파일을 만들어서 지각자를 관리하기 시작했다.
{% endblockquote %}

```text 지각자.txt
7월 25일 지각자 명단

나연
채영
사나
쯔위
```

{% blockquote %}
자, 이제 철수와 영희는 사장님으로부터 지각자를 관리할 수 있는 권력을 부여받았고, 매일 이 파일에 지각자를 입력해야한다. 하지만 철수와 영희는 별로 사이가 안 좋기 때문에 이 둘은 서로 커뮤니케이션을 하지 않고 각자 맘대로 파일을 수정하는 방식으로 지각자 입력 작업을 진행하게 된다.

그러던 중 철수와 영희는 사무실에 심어놓은 자신들의 정보원으로부터 7월 25일의 세번째 지각자인 `사나`가 사실 지각이 아니였다는 정보를 입수했다. 근데 문제는 이 정보원들이 가져온 정보가 서로 달랐던 것이다.

**철수의 정보원:** 야 7월 25일에 지각한 사람 있잖아, 사나가 아니고 미나래!
**영희의 정보원:** 영희야, 7월 25일에 사나가 지각한게 아니고 지효가 지각한거라는데?

...

이 둘은 자신의 정보원을 100% 신뢰하기 때문에 바로 각자 지각자 명단 파일을 수정하기 시작했다.
{% endblockquote %}

| 시간 | 철수 | 영희 |
|--|--|--|
| 1 | `지각자.txt`의 `사나`를 `미나`로 변경 | `지각자.txt`의 `사나`를 `지효`로 변경 |
| 2 | 리모트 저장소에 변경 사항 커밋 후 푸쉬 | 계속 작업 중 |
| 3 | 철수 퇴근 >_< | 작업을 마치고 리모트 저장소에 푸쉬 시도 |
| 4 | | 리모트 저장소의 상태가 갱신되었으니 Pull부터 하라는 에러 발생. 엥? |
| 5 | | 리모트 저장소의 변경 사항을 로컬로 Pull함 |
| 6 | | 철수가 수정한 부분과 영희가 수정한 부분이 충돌! |

```
From https://github.com/evan-moon/conflict-test
 * branch            test       -> FETCH_HEAD
Auto-merging 지각자.txt
CONFLICT (content): Merge conflict in 지각자.txt
Automatic merge failed; fix conflicts and then commit the result.
```

이렇게 다른 사람과 내가 같은 부분을 수정하게 되면, Git은 어떤 것이 맞는 소스인지 알 방법이 없다. 이런 상황에서 Git은 어떤 부분이 충돌났는지 표시하여 사용자에게 알려주기만 하고 나머지는 사용자가 알아서 수정하라고 맡겨버리는데, 이런 상황이 바로 `병합 충돌(Merge Conflict)`이다. 위의 철수와 영희 처럼 같은 브랜치에서 작업한다는 것은 소스의 변경 사항을 계속 히스토리를 공유한다는 것이다. 즉, 주기적으로 리모트 저장소로부터 상대방이 작업한 것을 `Pull`로 가져와서 내 로컬 브랜치에 병합해야한다는 것인데, 이 과정에서 충돌이 발생할 가능성이 높다.

```text
7월 25일 지각자 명단

나연
채영
<<<<<<< HEAD
지효
=======
미나
>>>>>>> 35058b46325bb61112efd52f4019f907c561328d
쯔위
```

이때 `<<< HEAD`와 `===`사이에 들어있는 상단 부분이 현재 브랜치에서 내가 수정한 내용이다. 영희는 `사나`를 `지효`로 수정했기 때문에 해당 부분에 `지효`라는 이름이 들어가 있다.

그리고 `===`부터 `>>> 커밋 해쉬`사이의 내용은 어떤 커밋에서 수정된 내용과 충돌이 발생했는지 알려준다. 이 예시에서는 철수가 `사나`를 `미나`로 수정한 부분이 될 것이다.

Git은 그냥 버전 관리만 해주는 친구이기 때문에 이런 상황에서 `사나는 사실 지각자가 아니였기 때문에 다른 사람으로 변경해야했다`와 같은 비즈니스 히스토리는 모른다. 그렇기 때문에 Git은 둘 중에 어떤 것이 맞는 소스인지도 당연히 모를 수 밖에 없다. 그래서 사용자에게 선택을 맡기는 것이다. 이 상황에서 영희는 다음 세가지 선택지를 가질 수 있다.

{% blockquote %}
1. 철수의 변경 사항을 무시
2. 자신의 변경 사항을 무시
3. 두 변경 사항 모두 반영
{% endblockquote %}

보통 이런 상황에서는 철수를 불러서 `사나` 대신 `미나`를 추가한 이유가 무엇인지 물어본 다음 결정해야하지만 영희는 철수와 사이가 좋지 않으니 그냥 철수의 커밋을 날려버릴 수도 있겠다.<small>(실제 상황에서 함부로 이러면 혼납니다)</small>

### 여러 개의 Branch를 사용하는 이유
`브랜치(Branch)`는 {% post_link git-tutorial 저번 포스팅 %}에서 한번 간단하게 설명했다. 하지만 저번 포스팅에서는 기초적인 브랜치의 개념에 대해서만 살짝 언급하고 넘어갔기 떄문에 이번에는 자세히 이야기해보려 한다.

기본적으로 Git은 혼자 만의 작업이 아닌 여러 명이 함께 작업하는 `협업` 상황을 상정하고 만들어졌다. 아무리 Git이 리모트 레파지토리와 로컬 레파지토리로 소스를 분산해서 관리하는 `분산 버전 관리 시스템`이지만 여러 사람이 한번에 같은 어플리케이션의 코드를 수정하고 있는 상황에서는 방금 위에서 설명한 `머지 컨플릭트`가 자주 발생하게된다. 그래서 보통 사용자들은 `브랜치`로 주제에 맞는 작업 공간을 따로 나누어서 히스토리를 관리하는 것이다.

이렇게 브랜치를 나누어도 결국 언젠가 소스를 병합해야 하기 때문에 컨플릭트가 발생할 확률은 있지만 적어도 작업 중간중간에 계속 해서 컨플릭트를 수정해야하는 일은 많이 줄일 수 있다. 그래서 개발자들은 `어떻게 해야 효율적으로 브랜치를 관리할 수 있을까?`라는 고민을 하게 되는데, 이때 나온 것이 바로 `브랜치 전략`이다. 브랜치 전략 중 대표적인 것은 `Git flow`가 있는데, 이건 그냥 유명한 전략 중 하나일 뿐이기 때문에 어떤 브랜치 전략을 가져갈 것인지는 그 조직이 결정하면 된다.

그럼 브랜치 전략이 어떤 것인지 알아보기 위해 대표적인 브랜치 전략인 `Git flow`를 한번 간략하게 살펴보도록 하자.

#### 전략적인 브랜치 관리, Git flow
`Git flow`는 기본적으로 `master`와 `develop` 브랜치를 가지고 시작하게 된다. 이때 `master`는 항상 운영되고 있는 소스의 상태를 가지고 있어야하며, 절대 `master` 브랜치에는 바로 커밋을 할 수 없다. 그리고 `develop` 브랜치는 팀이 현재 개발을 진행하고 있는 브랜치이다. 그리고 `develop` 브랜치에서 각자 개발을 맡고 있는 기능 별로 `feature` 브랜치를 생성해서 실제 개발을 진행하게 된다.

<center>
  {% asset_img git-flow1.png %}
  <br>
</center>

모바일에서는 이 그래프의 내용이 잘 안보일 수 있으니 브랜치 이름에 색을 입혀서 설명하도록 하겠다.

이 그래프를 보면 **<font color="blue">master</font>** 브랜치에 프로젝트의 시작을 의미하는 커밋이 찍힌 후 **<font color="red">develop</font>** 브랜치가 생성되었고, **<font color="red">develop</font>**에서부터 기능 개발을 담당하는 브랜치들이 분기하고 있는 모습을 볼 수 있다.

에반은 **<font color="green">feature/add-typescript</font>** 브랜치를 생성한 후 어플리케이션에 타입스크립트를 붙히는 작업을 하고, 다니엘은 **<font color="magenta">feature/social-login</font>** 브랜치를 생성한 후 소셜 로그인 연동 작업을 하고 있다. 그 후 개발이 끝나는 대로 **<font color="red">develop</font>** 브랜치에 해당 브랜치들을 차례로 머지하고 있는 모습을 볼 수 있다.

다니엘이 에반보다 **<font color="red">develop</font>** 브랜치에 머지한 시점이 늦기 때문에 만약 에반과 다니엘이 같은 부분을 변경했다면 이때 컨플릭트가 발생하게 된다. 하지만 적어도 에반과 다니엘이 각자 기능을 개발하고 있을때는 컨플릭트가 발생하지 않기 때문에 좀 더 기능 개발에 집중할 수 있게 되는 것이다.

이렇게 개발을 쭉쭉 진행하다가 배포를 해야할 시점이 오면 **<font color="blue">master</font>**로부터 `release`브랜치를 생성한다. 필자의 직장같은 경우는 `release/release-1.0.0`과 같이 배포 버전을 브랜치 이름에 표기하는 네이밍 컨벤션을 따르고 있다. 이 `release` 브랜치는 온전히 배포 만을 위한 브랜치이기 때문에 해당 버전의 배포가 끝나면 버려진다.

<center>
  {% asset_img git-flow2.png %}
  <br>
</center>

개발이 종료되고 `1.0.0` 버전을 배포하기 위해 **<font color="orange">release/release-1.0.0</font>**이라는 노란색 브랜치를 **<font color="blue">master</font>**로부터 하나 생성했다. 그 후 다음 버전에 배포될 기능들을 가지고 있는 **<font color="red">develop</font>** 브랜치를 **<font color="orange">release/release-1.0.0</font>** 브랜치에 머지하고 스테이징 서버에 배포하는 등 최종 테스트를 한 다음, 조직원 모두가 해당 버전의 배포에 동의한다면 **<font color="blue">master</font>** 브랜치에 해당 브랜치를 머지하고 버전명으로 태그를 단다.

이때 이런 궁금증이 생기는 분이 있을 것이다.

{% blockquote %}
그럼 핫픽스는 어떻게 하나요? develop 브랜치에서 브랜치를 분기하면 현재 버전의 기능 개발이 끝날 때까지 기다려야하는데...
{% endblockquote %}

이런 경우 `develop` 브랜치에서 `hotfix` 브랜치를 분기하여 `master`로 머지 후 긴급 배포를 하게되면 `develop` 브랜치에 들어있는 아직 배포되지 말아야할 기능들까지 배포되기 때문에, 핫픽스는 예외적으로 `master`에서 분기해서 다시 `master`로 머지할 수 있다.

<center>
  {% asset_img git-flow3.png %}
  <br>
</center>

그래프가 조금 복잡해졌지만 검정색 라인인 **hotfix/fix-main-page**에만 집중해보자. **<font color="blue">master</font>** 브랜치로부터 갈라져나와서 한 개의 커밋이 찍히고 다시 **<font color="blue">master</font>**로 머지되는 것을 볼 수 있다. 이때는 정식 릴리즈가 아닌 핫픽스 릴리즈이므로 [Sementic Version](https://semver.org/lang/ko/) 룰에 따라 `0.0.1` 버전의 태그를 달아주었다.

**hotfix/fix-main-page** 브랜치가 머지되고 배포가 되었다는 것은 현재 운영 환경에서 돌아가고 있는 소스가 변경되었다는 것이므로 **<font color="red">develop</font>**에도 해당 변경 사항을 반영을 해줘야한다. 그렇기 때문에 핫픽스 담당자는 배포를 하고 나면 `develop` 브랜치를 직접 최신화하는 것이 좋다. 그리고 동료들에게 `지금 핫픽스 배포가 끝났으니 각자 작업하시는 브랜치에서 develop 브랜치를 Pull하여 최신화 해주세요~`라고 알려주면 더더욱 좋을 것이다.

물론 이런 복잡한 브랜치 전략 없이도 그냥 잘 돌아가는 조직도 있다. 하지만 같은 소스를 만지는 개발자가 많아지면 많아질수록 어느 정도의 룰조차 없다면 원활한 협업이 진행되기는 힘들 수도 있기 때문에 대부분의 규모있는 조직에서는 각자의 상황에 맞는 브랜치 전략을 세워서 버전 관리를 진행하고 있다.

## 버전을 더 잘 관리하기 위한 명령어
저번 포스팅의 마지막에서 얘기 했듯이 실무에서 Git을 사용한 버전 관리를 진행하다보면 다른 개발자가 개발한 모듈 중에 하나만 내 브랜치로 가져와야 한다거나, 커밋이 꼬여서 소스가 지워졌다거나 하는 슬픈 상황들이 발생하기 마련이다. 그래서 이번 포스팅에서는 자유자재로 Git을 다루기 위한 몇 가지 명령어를 더 설명하려고 한다.

### Rebase
`리베이스(Rebase)`는 `머지(Merge)`와 마찬가지로 브랜치를 다른 브랜치로 합칠 수 있는 기능이다. 단 머지와 차이가 있다면 바로 `합치는 방식`이다. 머지는 말 그대로 두 개의 브랜치를 하나로 합치는 기능이기 때문에 `A` 브랜치의 변경 사항 전부를 `B` 브랜치에 푸쉬하는 것과 동일하다. 그렇기 때문에 머지를 사용하여 브랜치를 합치게 되면 반드시 `머지 커밋(Merge commit)`이 남게 된다.

```bash
$ git checkout feature
$ git merge master
```

<center>
  {% asset_img merge.svg 500 %}
  <small>[출처] [Merging vs. Rebasing](https://dzone.com/articles/merging-vs-rebasing)</small>
  <br>
</center>

그렇기 때문에 머지는 어느 시점에 어떤 브랜치가 머지 되었는 지 커밋을 통해 알기 쉽다는 장점이 있다. 그러나 단점은 `불필요한 커밋`이 생성된다는 것이다. 이 단점은 작업 중인 브랜치가 별로 많지 않을 때는 나타나지 않지만 브랜치가 많아지면 나중엔 커밋 로그가 머지 커밋으로 뒤덮혀있는 광경을 볼 수도 있게 된다.

반면 리베이스는 단순히 합치는 것이 아니라 말 그대로 `브랜치의 베이스를 변경하는 것`이다. 방금 전 예시의 `feature` 브랜치를 `master`로 리베이스하게 되면 마치 `feature` 브랜치의 변경 사항들이 `master`의 변경 사항이었던 것처럼 히스토리가 기록된다.

```bash
$ git checkout feature
$ git rebase master
```
<center>
  {% asset_img rebase.svg 500 %}
  <small>[출처] [Merging vs. Rebasing](https://dzone.com/articles/merging-vs-rebasing)</small>
  <br>
</center>

리베이스의 장점은 바로 깔끔한 커밋 히스토리를 만들어 준다는 것이다. 머지 커밋이 남지 않고 애초에 `master`에서 수정한 것 마냥 히스토리가 남기 때문에 깔끔하게 일자로 쭉 떨어지는 이쁜 히스토리를 볼 수 있다. 하지만 리베이스의 단점은 바로 이 `커밋 끼워넣기` 때문에 발생하는 문제이다.

<center>
  {% asset_img rebase-problem.svg 500 %}
  <small>[출처] [Merging vs. Rebasing](https://dzone.com/articles/merging-vs-rebasing)</small>
  <br>
</center>

필자가 만약 `feature` 브랜치를 `master`로 리베이스했다고 가정해보자. 이때 필자가 `feature` 브랜치를 생성한 이후에 `master`에 반영된 커밋들은 모두 맨 끝으로 이동하고 중간에 `feature` 브랜치의 커밋들을 끼워넣게 된다. 이렇게 되면 필자가 보고 있는 `master`의 상태는 `feature`의 변경 사항들이 반영되어 있는 히스토리를 가지고 있지만 다른 사람의 `master`는 아직 예전 `master`의 히스토리와 함께 일하고 있다는 것이다.

그럼 두개의 `master`를 강제로 병합해줘야하는데 병합 자체는 푸쉬할때 `--force` 옵션을 주면 되지만 문제는 이게 굉장히 혼란스러운 상황이라는 것이다. 쉽게 말해서 커밋이 꼬이게 되고 사무실의 여기저기서 `어? 이거 왜 이래? 왜 푸시 안돼?`라는 소리가 들려오기 딱 좋은 상황이다.

그래서 많은 조직에서 `master`로의 병합은 주로 머지를 사용하고 `develop`으로의 병합 때 리베이스를 사용하는 경우가 많다. 머지는 머지 커밋을 발생시키며 히스토리가 `미래`로 나아가기 때문에 이런 문제가 발생하지 않지만, 리베이스는 `과거`를 변경하는 것이기 때문에 문제가 생기기 쉬운 것이다.

뭐 여러모로 둘 다 장점이 있으니 잘 골라서 사용하도록 하자.

### Merge squash
이번에는 리베이스와 마찬가지로 두 개의 브랜치를 병합할 때 사용하는 머지 명령어의 `--squash` 옵션을 한번 알아보자. `--squash` 옵션은 해당 브랜치의 커밋 전체를 통합한 커밋을 타겟 브랜치에 머지하는 옵션이다.

```bash
$ git checkout master
$ git merge --squash feature 
```

쉽게 생각하면 `feature` 브랜치에서 커밋했던 모든 내용을 하나로 묶어서 `master`로 머지한다고 생각하면 편하다. `일반 머지`, `머지 스쿼시`, `리베이스`는 뭔가 비슷하면서도 다른 것 같지만 작업을 수행한 후의 히스토리가 완전 달라지기 때문에 개념을 잘 이해해놓고 실무에서 적재적소에 사용하면 이쁨받는 깃쟁이가 될 수 있다.

<center>
  {% asset_img merges.jpg %}
</center>

위 그림에서 볼 수 있듯이 `일반 머지`는 머지가 되는 대상 브랜치의 모든 커밋이 남아있고 타겟 브랜치로 합쳐진다. `머지 스쿼시`는 실제 히스토리가 저렇게 남지는 않지만 대상 브랜치의 모든 커밋을 모아서 하나로 합치고 타겟 브랜치로 들어가는 느낌, `리베이스`는 아예 대상 히스토리의 모든 커밋을 가져와서 타겟 브랜치의 히스토리에 끼워넣는 느낌이다. 비록 발그림이지만 이해가 되었길 바란다.<small>(구글 프레젠테이션으로 열심히 그렸다)</small>

### Cherry Pick
`체리픽(Cherry Pick)`은 다른 브랜치에서 어떤 하나의 커밋만 내 브랜치로 가져오는 기능이다. 체리픽이 실제로 하는 일은 대상 브랜치의 커밋 하나를 가져와서 현재 브랜치에 `병합`하는 행위라고 느껴지지만 히스토리를 보면 `병합`되는 그림이 아니라 그냥 해당 커밋을 그래도 복사해와서 내 브랜치에 커밋되는 형태로 기록된다.

```bash
$ git checkout master
$ git cherry-pick 35058b4 # 가져올 커밋 해쉬
```

물론 체리픽을 사용할 때도 현재 브랜치의 소스와 충돌이 날 가능성은 있기 때문에 가져오기 전에 충돌을 수정할 수도 있다는 마음의 준비는 필요하다. 체리픽은 잘 쓰면 은근히 꿀 기능인데, 바로 이런 상황 때문이다.

{% blockquote %}
1. A 브랜치에서 철수가 기능 개발 중
2. B 브랜치에서 영희가 기능 개발 중
3. 디자이너가 영희에게 리뷰 별점 아이콘과 디자인을 변경해달라고 요청
4. 영희가 B 브랜치에서 디자이너의 요구 사항을 반영
5. 근데 B 브랜치보다 A 브랜치가 먼저 배포되야 함
6. 디자이너가 철수에게 A 브랜치에 왜 리뷰 별점 디자인 반영안됐냐고 물어봄
{% endblockquote %}

제일 좋은 상황은 철수가 디자이너의 요구 사항을 반영하는 것이겠지만, 막 정신없이 일을 하다보면 그렇게 술술 풀리는 경우만 있는 게 아니기 때문에 이런 문제는 꽤 자주 발생한다고 생각한다.
이때 철수는 영희가 작업하고 있는 B 브랜치에서 `리뷰 별점 아이콘이 수정된 커밋`을 A 브랜치로 체리픽함으로써 이 상황을 쉽게 해결할 수 있게 된다. 이런 사람 애매해지게 만드는 상황은 생각보다 자주 발생하기 때문에 체리픽에 익숙해지는 것을 추천한다.

사실 이 상황은 필자가 얼마 전에 겪은 상황인데 철수가 필자이고 영희가 동료 프론트엔드 개발자였다. 그래서 동료 개발자분과 B 브랜치의 커밋 로그를 봤는데, `리뷰 별점 아이콘만 수정`된 커밋이 아니라 다른 변경 사항도 함께 묻어있는 커밋 밖에 없어서 디자이너와 딜을 할 수 밖에 없었고, `그럼 B 브랜치가 배포될 때 한꺼번에 같이 반영해주세요~`라는 결론으로 무사히 넘어갈 수 있었다.<small>(디자이너님 감사감사...)</small>

### Stash

### Commit --amend

### Revert


