---
title: Git 뉴비를 위한 기초 사용법 - 2
toc: true
widgets:
  - type: toc
    position: right
  - type: category
    position: right
sidebar:
  right:
    sticky: true
tags:
  - 튜토리얼
  - Git
  - Tutorial
  - Versioning
  - 협업
  - 버전관리
categories:
  - Methodology
thumbnail:
---

이번 포스팅에서는 저번 포스팅인 {% post_link git-tutorial Git 뉴비를 위한 기초 사용법 %}에서 설명했던 기본적인 명령어보다 좀 더 나아가서 몇가지 개념과 명령어를 더 공부해보려고 한다. 저번 포스팅에서는 리모트 서버에서 소스를 클론하고 수정한 후 다시 리모트 서버에 업데이트하는 과정에 대해 집중해서 설명했다면 이번 포스팅에서는 Git의 메인 주제인 `버전 관리`에 대해 더 다뤄볼 예정이다.
<!-- more -->

그럼 저번 포스팅과 마찬가지로 간단한 용어와 개념에 대한 설명한 후, 그 개념들을 사용하기 위한 명령어를 설명하도록 하겠다.

## 용어과 개념 알아보기
Git은 버전을 효율적으로 관리하기 위해 몇 가지 개념을 제시하고 있다. 현재 나의 버전 상태를 의미하는 `HEAD`, 작업 공간인 `브랜치(Branch)`, 브랜치를 합치는 `머지(Merge)`와 `리베이스(Rebase)`등이 그렇다. 그리고 이런 기능들을 사용하다보면 가끔 Git의 `에러`와 마주하게 되는데, 필자같은 경우는 처음 개발자로 일을 시작했을 때 코딩하다가 발생하는 에러보다 Git에서 발생하는  에러가 더 무서웠던 기억이 있다. 솔직히 코딩하다가 나는 에러는 고치는 과정이 쉽든 어렵든간에 그냥 필자가 고치면 해결되지만, Git에서 나는 에러는 고친답시고 이것 저것 건드리다가 잘못 건드리면 왠지 소스가 가루가 되어 날아갈 것 같아서 무서웠다.

하지만 Git을 사용한 지 6년쯤 지난 지금 다시 그때를 생각해보면 Git에 대해서 잘 몰랐기 때문에 더 무서웠던 것 같다. 내가 어떤 기능을 사용했을 때 소스 버전이 어떻게 되는 지 정확히 알고 있지 않은 상태였기 때문에 그런 걱정도 들었던 것이다. 혹시 이 글을 읽는 독자 분들 중에서도 필자와 같은 경험이나 생각을 하신 분들이 있을 것이기 때문에 필자가 알고 있는 Git의 개념들을 최대한 알기 쉽게 풀어보려고 한다.

그럼 이제 하나하나씩 살펴보도록 하자.

### Merge Conflict
필자 생각에 Git을 사용하다가 가장 많이 마주치는 에러는 아무래도 `머지 컨플릭트(Merge Conflict)`인 것 같다. 에러라고 하기에는 조금 애매하긴 하지만 어쨌든 정상은 아닌 상황이기 때문에 처음 마주하면 굉장히 당황스럽고 뭐가 뭔지 헷갈린다. 컨플릭트는 말 그대로 `소스의 충돌`이 발생한 상황이기 때문에 주니어든 시니어든 가리지 않고 평등하게 발생하고, 또한 평등하게 당황시킨다.

왜냐면 컨플릭트는 논리적인 에러가 아니라 내 작업물과 다른 사람의 작업물이 충돌한 상황이기 때문에 스스로 혼자 해결하기 힘든 경우가 많기 때문이다. 그럼 컨플릭트, 즉 충돌이 정확히 어떤 상황을 말하는 지 알기 위해 실제 협업 상황에서 발생할 수 있는 예시를 함께 살펴보자.

{% blockquote %}
`철수`와 `영희`는 사장님으로부터 지각한 사람의 명단을 만들어서 관리해 달라는 부탁을 받았다. 그래서 철수와 영희는 다음과 같은 `txt` 파일을 만들어서 지각자를 관리하기 시작했다.
{% endblockquote %}

```text 지각자.txt
7월 25일 지각자 명단

나연
채영
사나
쯔위
```

{% blockquote %}
자, 이제 철수와 영희는 사장님으로부터 지각자를 관리할 수 있는 권력을 부여받았고, 매일 이 파일에 지각자를 입력해야한다.

하지만 철수와 영희는 별로 사이가 안 좋기 때문에 이 둘은 서로 커뮤니케이션을 하지 않고 각자 맘대로 파일을 수정하는 방식으로 지각자 입력 작업을 진행하게 된다.

그러던 중 철수와 영희는 사무실에 심어놓은 자신들의 정보원으로부터 7월 25일의 세번째 지각자인 `사나`가 사실 지각이 아니였다는 정보를 입수했다. 근데 문제는 이 정보원들이 가져온 정보가 서로 달랐던 것이다.
{% endblockquote %}

| 시간 | 철수 | 영희 |
|--|--|--|
| 1 | `지각자.txt`의 `사나`를 `미나`로 변경 | `지각자.txt`의 `사나`를 `지효`로 변경 |
| 2 | 리모트 저장소에 변경 사항 커밋 후 푸쉬 | 계속 작업 중 |
| 3 | 철수 퇴근 >_< | 작업을 마치고 리모트 저장소에 푸쉬 시도 |
| 4 | | 리모트 저장소의 상태가 갱신되었다는 에러 발생 |
| 5 | | 리모트 저장소의 변경 사항을 로컬로 Pull함 |
| 6 | | 철수가 수정한 부분과 영희가 수정한 부분이 충돌! |

```
From https://github.com/evan-moon/conflict-test
 * branch            test       -> FETCH_HEAD
Auto-merging 지각자.txt
CONFLICT (content): Merge conflict in 지각자.txt
Automatic merge failed; fix conflicts and then commit the result.
```

이렇게 다른 사람과 내가 같은 부분을 수정하게 되면, Git은 어떤 것이 맞는 소스인지 알 방법이 없다. 이런 상황에서 Git은 어떤 부분이 충돌났는지 표시하여 사용자에게 알려주기만 하고 나머지는 사용자가 알아서 수정하라고 맡겨버리는데, 이런 상황이 바로 `병합 충돌(Merge Conflict)`이다. 위의 철수와 영희 처럼 같은 브랜치에서 작업한다는 것은 소스의 변경 사항을 계속 히스토리를 공유한다는 것이다. 즉, 주기적으로 리모트 저장소로부터 상대방이 작업한 것을 `Pull`로 가져와서 내 로컬 브랜치에 병합해야한다는 것인데, 이 과정에서 충돌이 발생할 가능성이 높다.

```text
7월 25일 지각자 명단

나연
채영
<<<<<<< HEAD
지효
=======
미나
>>>>>>> 35058b46325bb61112efd52f4019f907c561328d
쯔위
```

이때 `<<< HEAD`와 `===`사이에 들어있는 상단 부분이 현재 브랜치에서 내가 수정한 내용이다. 영희는 `사나`를 `지효`로 수정했기 때문에 해당 부분에 `지효`라는 이름이 들어가 있다.

그리고 `===`부터 `>>> 커밋 해쉬`사이의 내용은 어떤 커밋에서 수정된 내용과 충돌이 발생했는지 알려준다. 이 예시에서는 철수가 `사나`를 `미나`로 수정한 부분이 될 것이다.

Git은 그냥 버전 관리만 해주는 친구이기 때문에 이런 상황에서 `사나는 사실 지각자가 아니였기 때문에 다른 사람으로 변경해야했다`와 같은 비즈니스 히스토리는 모른다. 그렇기 때문에 Git은 둘 중에 어떤 것이 맞는 소스인지도 당연히 모를 수 밖에 없다. 그래서 사용자에게 선택을 맡기는 것이다. 이 상황에서 영희는 다음 세가지 선택지를 가질 수 있다.

{% blockquote %}
1. 철수의 변경 사항을 무시
2. 자신의 변경 사항을 무시
3. 두 변경 사항 모두 반영
{% endblockquote %}

보통 이런 상황에서는 철수를 불러서 `사나` 대신 `미나`를 추가한 이유가 무엇인지 물어본 다음 결정해야하지만 영희는 철수와 사이가 좋지 않으니 그냥 철수의 커밋을 날려버릴 수도 있겠다.<small>(실제 상황에서 이러면 혼납니다)</small>

### Branch를 사용하는 이유
`브랜치(Branch)`는 {% post_link git-tutorial 저번 포스팅 %}에서 한번 간단하게 설명했다. 하지만 저번 포스팅에서는 기초적인 브랜치의 개념에 대해서만 살짝 언급하고 넘어갔기 떄문에 이번에는 자세히 이야기해보려 한다.

기본적으로 Git은 혼자 만의 작업이 아닌 여러 명이 함께 작업하는 `협업` 상황을 상정하고 만들어졌다. 아무리 Git이 리모트 레파지토리와 로컬 레파지토리로 소스를 분산해서 관리하는 `분산 버전 관리 시스템`이지만 여러 사람이 한번에 같은 어플리케이션의 코드를 수정하고 있는 상황에서는 이런 상황이 발생하게 된다.






