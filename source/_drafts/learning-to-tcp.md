---
title: TCP 자세히 파헤쳐보기(가제)
toc: true
widgets:
  - type: toc
    position: right
  - type: category
    position: right
sidebar:
  right:
    sticky: true
tags:
categories:
  - Programming
  - Network
thumbnail:
---

저번에 {% post_link what-is-http3 HTTP/3는 왜 UDP를 선택한 것일까? %} 포스팅을 진행하며 TCP에 대해 간단한 언급을 했었지만, 해당 포스팅에서는 기존에 HTTP에서 사용하던 TCP에 어떤 문제가 있었는지에 집중해서 이야기했었지만 이번에는 TCP 자체에 조금 더 집중해서 이야기해보려고 한다.

<!-- more -->

## TCP, Transmission Control Protocol
`TCP(Transmission Control Protocol)`는 OSI 7계층 중 전송 계층에서 사용되고 있는 프로토콜로, 장비들 간의 통신 과정에서 정보를 안정적으로, 순서대로, 에러없이 교환할 수 있도록 하는 것에 목적을 둔 프로토콜이다.

컴퓨터 공학에서는 컴퓨터에게 가까운 부분일 수록 `낮다`거나 `뒤에 있다`는 표현을, 사람에게 가까운 `높다`거나 `앞에 있다`라는 표현을 자주 사용하는데, OSI 7계층에서도 마찬가지로 낮은 계층일수록 기계에 가까운 부분이고 높은 부분일수록 사람에게 가까운 부분이라고 생각하면 편하다.

<center>
  {% asset_img osi.png 500 %}
  <br>
</center>

이때 우리에게 친숙한 `HTTP`, `SMTP`, `FTP`와 같은 프로토콜 친구들이 가장 높은 계층인 응용 계층에 위치한다. 그에 비해 더 낮은 계층에 존재하는 `TCP`, `UDP`, `IP` 같은 프로토콜들은 상대적으로 접할 일이 많이 없기는 하다.

이런 프로토콜들은 대부분 OS에서 알아서 처리해주기 때문에 일반적인 개발자가 굳이 여기서 일어나는 일까지 하나하나 신경쓸 필요가 없기 떄문이다.

애초에 이런 레이어 모델들이 존재하는 이유 중에 이거다. 각 계층 간 철저한 역할 분담을 통해 어떤 작업을 할 때 신경써야하는 범위를 좁혀주는 것이다. 덕분에 우리는 HTTP를 사용할 때 DNS는 어디를 사용할지, 패킷은 어떻게 처리할지 등 여러 가지 작업을 한번에 신경쓸 필요가 없다.

하지만 TCP는 아직까지도 IP와 함께 인터넷을 구성하는 주력 프로토콜인 만큼, 웹 개발자로써 TCP가 통신에서 어떤 역할을 하고 있는지 정도는 알아야한다고 생각한다.

### TCP는 왜 만들어진걸까?
개인적으로 어떤 기술을 공부할 때, 무작정 외우는 것이 아니라 `이게 왜 필요한 것인지`를 알고 그 이유에 대해 공감하며 공부하는 편이 효과적이라고 생각한다.

TCP는 워낙 옛날에 나온 기술이니 당시 상황을 100% 공감하기는 쉽지 않겠지만, 그래도 이 프로토콜이 개발된 이유를 살펴보면 당시 엔지니어들의 고충을 알아볼 수 있다.

TCP는 방금 이야기 했듯이 1970년 냉전 당시 미 국방성이 개발하던 알파넷 프로젝트의 일부로 개발되었는데, 그 당시 알파넷을 연구할 때 관심을 가진 주제 중에 하나가 바로 `핵전쟁이 나도 살아남는 네트워크`였다.<small>(핵전쟁의 상대방은 당연히 마더 러씨아...)</small>

왜냐하면 1970년대의 네트워크는 `회선 교환 방식`을 사용하고 있었기 때문에 중계국이 폭격을 맞아서 박살나거나 중간에 연결된 선이 하나가 잘려나가면 그대로 통신이 끊어져 버렸기 때문이다.

<center>
  {% asset_img old-telephone.jpg 500 %}
  <small>직접 보지는 않았지만 이런 느낌이지 않았을까...?</small>
  <br>
</center>

저 당시 중계국이 하는 일은 그냥 이거다. A가 중계국에 "B랑 연결해주세요!"라고 하면, 위의 사진과 같이 케이블이 마구 꽂혀있는 패치 테이블에서 A 라벨이 붙은 구멍과 B 라벨이 붙은 구멍을 찾아서 케이블로 연결해준다. 그러면 A와 B가 연결된 것이다.

말 그대로 계속 해서 `회선을 교환`하는 것이다. 저러다가 A가 C랑 통신하고 싶으면 B 구멍에서 케이블을 빼서 C 구멍에 꽂으면 된다.

이렇게 회선 교환 방식의 경우에는 통신을 하고 싶은 상대방과 물리적으로 회선을 하나 딱 잡아놓고 계속 통신을 하는 것이기 때문에 회선의 효율이 낮을 수 밖에 없다. 우리가 전화를 걸 때 상대방이 통화 중이면 `상대방이 통화 중이니...` 어쩌고 나오는 것과 같은 원리이다.

물론 회선을 독점하기 때문에 대량의 데이터를 고속으로 주르륵 보낼 수 있는 등의 장점도 있긴 하지만, 이때 미국에게 중요한 것은 `핵이 터져도 끊기지 않는 통신`이었기 때문에 하나의 회선에 전적으로 의존하는 통신이라는 건 큰 단점으로 다가왔을 것이다.

그래서 나온 아이디어가 바로 `패킷 교환 방식`이다. 데이터를 하나의 회선을 사용하여 보내다가 해당 회선이나 중계국이 개박살나면 전송되던 데이터와도 영원히 이별하게 되니, 데이터를 잘게 쪼갠 후 여러 개의 회선을 통해 보내자는 것이다. 일종의 분산투자랄까.

<center>
  {% asset_img packats.png 500 %}
  <small>이렇게 되면 노드 하나가 박살나도 모든 데이터가 유실되진 않을 것이다</small>
  <br>
</center>

최악의 경우 중간에 있는 회선이나 중계국이 박살나서 데이터가 약간 유실될 수는 있겠지만 전체 네트워크를 한 번에 타격하지 않는 이상 모든 데이터가 유실될 가능성은 없다. 또한 하나의 회선을 잡아놓고 계속 통신하는 것이 아니라 패킷에 목적지를 마킹해놓고 그냥 보내기만 하면 되니, 회선의 사용 효율 또한 높아질 수 있다.

이런 이유로 미 국방성은 이 아이디어를 채택하여 알파넷에 적용했고, 초기 테스트도 대성공하여 패킷 교환 방식의 실용성을 증명했다. 하지만 모든 기술에는 장단점이 있기 마련이다.

패킷 교환 방식에도 중간에 패킷이 쥐도새도 모르게 사라진다던가, 패킷을 쪼개놓은 순서를 알기위해 헤더에 별도의 정보를 추가해야한다던가, 수신하는 쪽의 버퍼가 넘쳐버리면 그 이후에 들어온 패킷은 처리하기가 애매하다던가 하는 단점이 있었다.

결국 TCP가 담당하고 있는 흐름 제어, 혼잡 제어 등의 기능은 이런 패킷 교환 방식의 단점들을 커버하기 위해 존재하는 것이다.

## TCP의 특징
우리가 알고 있는 TCP의 대표적인 특징은 다음과 같다.

{% blockquote %}
- 연결 지향 방식이다
- 신뢰성이 보장된다
- 느리다
{% endblockquote %}

이 중 마지막에 있는 `느리다`라는 이야기는 통신의 신뢰성을 보장하기 위해 이것저것 절차가 많은 TCP의 특성 상 자연스럽게 따라오는 결과이므로, 이 포스팅에서는 위의 두 가지 이유만 한번 살펴보도록 하겠다.

### 연결 지향 방식이다
`연결 지향(Connection Oriented)`은 말 그대로 연결되어 있는 상태를 지향한다는 의미이다. 사실 `연결`과 `비연결`은 네트워크를 공부하다보면 여러 번 마주치게 되는 단어인데, 필자는 개인적으로 이 단어들의 의미가 조금 헷갈렸었다.

상식적으로 두 기기가 통신을 하려면 케이블이든 뭐든 연결이 되어있어야 할텐데, 굳이 왜 `연결 지향`과 `비연결 지향`을 나누어 놓은 것인지 이해가 되지 않았기 떄문이다.

여기서 헷갈리는 이유는 `물리적인 연결`과 `논리적인 연결`의 차이 때문이다. 물리적인 연결이라는 것은 일반적으로 우리가 컴퓨터와 모니터를 연결하거나, 랜선을 컴퓨터에 연결한다거나 할 때 사용하는 말이다. 즉, 컴퓨터와 외부 장치 간의 `물리적인` 연결이다.

<center>
  {% asset_img physical-connection.png 500 %}
  <small>케이블을 사용하여 두 개의 장치를 물리적으로 연결한다</small>
  <br>
</center>

반면, `연결 지향`이라는 단어에서 사용하고 있는 연결의 의미는 `논리적인 연결(Logical Connection)`을 의미한다. 이때 당연히 여러 개의 기기가 서로 통신을 하기위해서는 물리적인 연결 또한 동반되어야한다.

<center>
  {% asset_img logical-connection.png 500 %}
  <br>
</center>

조금 더 쉽게 이야기해보자면, 두 기기가 서로 `연결되어 있는 상태`를 유지하는 것이다.

전화를 예로 들자면, 전화는 항상 전화선에 연결이 되어있는 것이 물리적인 연결이고 실제로 다른 전화와 통화를 하고 있는 상황이 논리적인 연결, 즉 `연결되어 있는 상태`인 것이다. 

### 패킷의 전송 순서를 보장

### 신뢰성은 높으나 전송 속도가 느리다


## 헤더 구조

<center>
  {% asset_img tcp-header.png %}
  <br>
</center>

## 3 Way Handshake

**LISTEN**
**SYN_SENT**
**SYN_RECV**
**ESTABLISHED**

## 4 Way Handshake

**FIN_WAIT1**
**CLOSE_WAIT**
**FIN_WAIT2**
**TIME_WAIT**
**LAST_WAIT**
**CLOSED**