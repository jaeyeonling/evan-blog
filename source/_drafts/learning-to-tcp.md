---
title: TCP 자세히 파헤쳐보기(가제)
toc: true
widgets:
  - type: toc
    position: right
  - type: category
    position: right
sidebar:
  right:
    sticky: true
tags:
categories:
  - Programming
  - Network
thumbnail:
---

저번에 {% post_link what-is-http3 HTTP/3는 왜 UDP를 선택한 것일까? %} 포스팅을 진행하며 TCP에 대해 간단한 언급을 했었지만, 해당 포스팅에서는 기존에 HTTP에서 사용하던 TCP에 어떤 문제가 있었는지에 집중해서 이야기했었지만 이번에는 TCP 자체에 조금 더 집중해서 이야기해보려고 한다.

<!-- more -->

## TCP, Transmission Control Protocol
`TCP(Transmission Control Protocol)`는 OSI 7계층 중 전송 계층에서 사용되고 있는 프로토콜로, 장비들 간의 통신 과정에서 정보를 안정적으로, 순서대로, 에러없이 교환할 수 있도록 하는 것에 목적을 둔 프로토콜이다.

컴퓨터 공학에서는 컴퓨터에게 가까운 부분일 수록 `낮다`거나 `뒤에 있다`는 표현을, 사람에게 가까운 `높다`거나 `앞에 있다`라는 표현을 자주 사용하는데, OSI 7계층에서도 마찬가지로 낮은 계층일수록 기계에 가까운 부분이고 높은 부분일수록 사람에게 가까운 부분이라고 생각하면 편하다.

<center>
  {% asset_img osi.png 500 %}
  <br>
</center>

이때 우리에게 친숙한 `HTTP`, `SMTP`, `FTP`와 같은 프로토콜 친구들이 가장 높은 계층인 응용 계층에 위치한다. 그에 비해 더 낮은 계층에 존재하는 `TCP`, `UDP`, `IP` 같은 프로토콜들은 상대적으로 접할 일이 많이 없기는 하다.

이런 프로토콜들은 대부분 OS에서 알아서 처리해주기 때문에 일반적인 개발자가 굳이 여기서 일어나는 일까지 하나하나 신경쓸 필요가 없기 떄문이다.

하지만 TCP는 아직까지도 IP와 함께 인터넷을 구성하는 주력 프로토콜인 만큼, 웹 개발자로써 TCP가 통신에서 어떤 역할을 하고 있는지 정도는 알아야한다고 생각한다.

### TCP는 왜 만들어진걸까?
개인적으로 어떤 기술을 공부할 때, 무작정 외우는 것이 아니라 `이게 왜 필요한 것인지`를 알고 그 이유에 대해 공감하며 공부하는 편이 효과적이라고 생각한다.

TCP는 1970년대에 `알파넷(ARPAnet)`을 사용하던 시절에 나온 기술이기 때문에 공감하기는 쉽지 않겠지만 그래도 이 프로토콜이 개발된 이유를 살펴보면 당시 엔지니어들의 고충을 알아볼 수 있다.

TCP는 방금 이야기 했듯이 미국 국방고등연구계획국이 개발하던 알파넷 프로젝트의 일부로 개발되었는데, 그 당시 알파넷을 연구할 때 관심을 가진 주제 중에 하나가 바로 `핵전쟁이 나도 살아남는 네트워크`였다.<small>(상대방은 당연히 마더 러씨아...)</small>

왜냐하면 1970년대의 네트워크는 `회선 교환 방식`을 사용하고 있었기 때문에 중계국이 폭격을 맞아서 박살나거나 중간에 연결된 선이 하나가 잘려나가면 그대로 통신이 끊어져 버렸기 때문이다.

<center>
  {% asset_img old-telephone.jpg 500 %}
  <small>직접 보지는 않았지만 이런 느낌이지 않았을까...?</small>
  <br>
</center>

그리고 이런 회선교환 방식의 경우에는 통신을 하고 싶은 상대방과 물리적으로 회선을 하나 딱 잡아놓고 계속 통신을 하는 것이기 때문에 회선의 이용률이 낮을 수 밖에 없다. 우리가 전화를 걸 때 상대방이 통화 중이면 `상대방이 통화 중이니...` 어쩌고 나오는 것과 같은 원리이다.

대신 회선을 독점하기 때문에 대량의 데이터를 고속으로 주르륵 보낼 수 있는 등의 장점도 있긴 하지만 이때 미국에게 중요한 것은 `핵이 터져도 살아남는 네트워크`였기 때문에 하나의 회선에 전적으로 의존하는 네트워크라는 건 큰 단점으로 다가왔을 것이다.

그래서 나온 아이디어가 바로 `패킷 교환 방식`이다. 데이터를 한 회선으로 한번에 보내다가 해당 회선이나 중계국이 개박살나면 데이터와도 영원히 이별하게 되니까, 한 개의 회선을 사용하는 것이 아니라 데이터를 잘게 쪼개서 여러 개의 회선을 통해 보내자는 것이다. 일종의 분산투자랄까.

<center>
  {% asset_img packats.png 500 %}
  <small>노드 하나가 박살나도 다른 데이터까지 전부 날라가진 않는다</small>
  <br>
</center>

### 연결 지향 방식이다
자, 그럼 먼저 `연결 지향(Connection Oriented)`이란 무엇일까? 상식적으로 두 기기가 통신을 하려면 케이블이든 뭐든 연결이 되어있어야 할텐데, 굳이 왜 `연결 지향`과 `비연결 지향`을 나누어 놓은 것일까?

여기서 헷갈리는 이유는 `물리적인 연결`과 `논리적인 연결`의 차이 때문이다. 물리적인 연결이라는 것은 일반적으로 우리가 컴퓨터와 모니터를 연결하거나, 랜선을 컴퓨터에 연결한다거나 할 때 사용하는 말이다. 즉, 컴퓨터와 외부 장치 간의 `물리적인` 연결이다.

<center>
  {% asset_img physical-connection.png 500 %}
  <small>케이블을 사용하여 두 개의 장치를 물리적으로 연결한다</small>
  <br>
</center>

반면, `연결 지향`이라는 단어에서 사용하고 있는 연결의 의미는 `논리적인 연결(Logical Connection)`을 의미한다. 당연히 여러 개의 기기가 서로 통신을 하기위해서는 물리적으로 연결이 되어있어야 한다. 

<center>
  {% asset_img logical-connection.png 500 %}
  <small>물리적인 연결이 아닌, 논리적인 연결은 이런 느낌이다</small>
  <br>
</center>

실제로 각 노드들은 케이블로 물리적인 연결이 되어있고, 

TCP라고 하면 주로 생각나는 핸드쉐이크 과정이 바로 이 연결을 생성하거나 끊을 때 겪는 과정이다. 

### 패킷의 전송 순서를 보장

### 신뢰성은 높으나 전송 속도가 느리다


## 헤더 구조

<center>
  {% asset_img tcp-header.png %}
  <br>
</center>

## 3 Way Handshake

**LISTEN**
**SYN_SENT**
**SYN_RECV**
**ESTABLISHED**

## 4 Way Handshake

**FIN_WAIT1**
**CLOSE_WAIT**
**FIN_WAIT2**
**TIME_WAIT**
**LAST_WAIT**
**CLOSED**