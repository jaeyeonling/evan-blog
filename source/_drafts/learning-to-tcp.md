---
title: "[TCP] TCP의 유래와 핸드쉐이크"
toc: true
widgets:
  - type: toc
    position: right
  - type: category
    position: right
sidebar:
  right:
    sticky: true
tags:
categories:
  - Programming
  - Network
thumbnail:
---

저번에 {% post_link what-is-http3 HTTP/3는 왜 UDP를 선택한 것일까? %} 포스팅을 진행하며 TCP에 대해 간단한 언급을 했었지만, 해당 포스팅에서는 기존에 HTTP에서 사용하던 TCP에 어떤 문제가 있었는지에 집중해서 이야기했었지만 이번에는 TCP 자체에 조금 더 집중해서 이야기해보려고 한다.

<!-- more -->

원래는 TCP의 유래, 연결 생성과 해제 시 발생하는 핸드쉐이크 과정, 흐름 제어, 혼잡 제어 등을 모두 다루려고 했으나 생각보다 양이 너무 많아서 두 개의 포스팅으로 나누어 작성하려고 한다.<small>(요즘 자꾸 분량 조절에 실패한다)</small>

그런 이유로 이번 포스팅에서는 TCP의 유래와 특징, 핸드쉐이크에 대해서만 집중적으로 파헤쳐 보도록 하겠다.

## TCP, Transmission Control Protocol
`TCP(Transmission Control Protocol)`는 OSI 7계층 중 전송 계층에서 사용되고 있는 프로토콜로, 장비들 간의 통신 과정에서 정보를 안정적으로, 순서대로, 에러없이 교환할 수 있도록 하는 것에 목적을 둔 프로토콜이다.

컴퓨터 공학에서는 컴퓨터에게 가까운 부분일 수록 `낮다`거나 `뒤에 있다`는 표현을, 사람에게 가까운 `높다`거나 `앞에 있다`라는 표현을 자주 사용하는데, OSI 7계층에서도 마찬가지로 낮은 계층일수록 기계에 가까운 부분이고 높은 부분일수록 사람에게 가까운 부분이라고 생각하면 편하다.

<center>
  {% asset_img osi.png 500 %}
  <br>
</center>

이때 우리에게 친숙한 `HTTP`, `SMTP`, `FTP`와 같은 프로토콜 친구들이 가장 높은 계층인 응용 계층에 위치한다. 그에 비해 더 낮은 계층에 존재하는 `TCP`, `UDP`, `IP` 같은 프로토콜들은 상대적으로 접할 일이 많이 없기는 하다.

이런 프로토콜들은 대부분 OS에서 알아서 처리해주기 때문에 상위 계층에서 프로그래밍을 하는 개발자가 굳이 여기서 일어나는 일까지 하나하나 신경쓸 필요가 없기 떄문이다.

애초에 이런 레이어 모델들이 존재하는 이유 중에 이거다. 애초에 네트워크라는 것이 수많은 기술의 집약체인 만큼 한 명의 개발자가 모든 것을 다 알기는 힘들다. 그래서 각 계층 간 철저한 역할 분담을 통해 어떤 작업을 할 때 신경써야하는 범위를 좁혀주는 것이다.

덕분에 우리는 HTTP를 사용할 때 DNS는 어디를 사용할지, 패킷은 어떻게 처리할지 등 여러 가지 작업을 한번에 신경쓸 필요가 없다.

하지만 TCP는 아직까지도 IP와 함께 인터넷을 구성하는 주력 프로토콜인 만큼, 웹 개발자로써 TCP가 통신에서 어떤 역할을 하고 있는지 정도는 알아야한다고 생각한다.

## TCP는 왜 만들어진걸까?
개인적으로 어떤 기술을 공부할 때, 무작정 외우는 것이 아니라 `이게 왜 필요한 것인지`를 알고 그 이유에 대해 공감하며 공부하는 편이 효과적이라고 생각한다.

TCP는 워낙 옛날에 나온 기술이니 당시 상황을 100% 공감하기는 쉽지 않겠지만, 그래도 이 프로토콜이 개발된 이유를 살펴보면 당시 엔지니어들의 고충을 알아볼 수 있다.

### 패킷 교환 방식을 사용해보자!

TCP는 방금 이야기 했듯이 1970년 냉전 당시 미 국방성이 개발하던 알파넷 프로젝트의 일부로 개발되었는데, 그 당시 알파넷을 연구할 때 관심을 가진 주제 중에 하나가 바로 `핵전쟁이 나도 살아남는 네트워크`였다.<small>(핵전쟁의 상대방은 당연히 마더 러씨아...)</small>

왜냐하면 1970년대의 네트워크는 `회선 교환 방식`을 사용하고 있었기 때문에 중계국이 폭격을 맞아서 박살나거나 중간에 연결된 선이 하나가 잘려나가면 그대로 통신이 끊어져 버렸기 때문이다.

<center>
  {% asset_img old-telephone.jpg 500 %}
  <small>직접 보지는 않았지만 이런 느낌이지 않았을까...?</small>
  <br>
</center>

저 당시 중계국이 하는 일은 그냥 이거다. A가 중계국에 "B랑 연결해주세요!"라고 하면, 위의 사진과 같이 케이블이 마구 꽂혀있는 패치 테이블에서 A 라벨이 붙은 구멍과 B 라벨이 붙은 구멍을 찾아서 케이블로 연결해준다. 그러면 A와 B가 연결된 것이다.

말 그대로 계속 해서 `회선을 교환`하는 것이다. 저러다가 A가 C랑 통신하고 싶으면 B 구멍에서 케이블을 빼서 C 구멍에 꽂으면 된다.

이렇게 회선 교환 방식의 경우에는 통신을 하고 싶은 상대방과 물리적으로 회선을 하나 딱 잡아놓고 계속 통신을 하는 것이기 때문에 회선의 효율이 낮을 수 밖에 없다. 우리가 전화를 걸 때 상대방이 통화 중이면 `상대방이 통화 중이니...` 어쩌고 나오는 것과 같은 원리이다.

물론 회선을 독점하기 때문에 대량의 데이터를 빠른 속도로 주르륵 보낼 수 있는 등의 장점도 있긴 하지만, 이때 미국에게 중요한 것은 `핵이 터져도 끊기지 않는 통신`이었기 때문에 하나의 회선에 전적으로 의존하는 통신이라는 건 큰 단점으로 다가왔을 것이다.

그래서 나온 아이디어가 바로 `패킷 교환 방식`이다. 데이터를 하나의 회선을 사용하여 보내다가 해당 회선이나 중계국이 개박살나면 전송되던 데이터와도 영원히 이별하게 되니, 데이터를 잘게 쪼갠 후 여러 개의 회선을 통해 보내자는 것이다. 일종의 분산투자랄까.

<center>
  {% asset_img packets.png 500 %}
  <small>이렇게 되면 노드 하나가 박살나도 모든 데이터가 유실되진 않을 것이다</small>
  <br>
</center>

최악의 경우 중간에 있는 회선이나 중계국이 박살나서 데이터가 약간 유실될 수는 있겠지만 전체 네트워크를 한 번에 타격하지 않는 이상 모든 데이터가 유실될 가능성은 없다. 또한 하나의 회선을 잡아놓고 계속 통신하는 것이 아니라 패킷에 목적지를 마킹해놓고 그냥 보내기만 하면 되니, 회선의 사용 효율 또한 높아질 수 있다.

이런 이유로 미 국방성은 이 아이디어를 채택하여 알파넷에 적용했고, 초기 테스트도 대성공하여 패킷 교환 방식의 실용성을 증명했다.

이후 몇 개의 대학과 군에서만 사용되던 알파넷이 대중들에게 공개되고 전 세계적으로 연결되며 인터넷으로 발전하게 되었고, 덩달아 알파넷의 통신 프로토콜이었던 TCP도 함께 떡상하게 된 것이다.

### 패킷 교환 방식의 문제점
하지만 패킷 교환 방식도 당연히 만능이 아니기에, 몇 가지 문제가 있었다. 우리가 TCP를 공부할 때 함께 따라오는 ARQ나 SYN, ACK 등의 개념들이 바로 이런 문제들을 해결하기 위해 과거의 엔지니어들이 머리를 싸맨 결과인 것이다.

{% blockquote %}
  Q: 전송 중간에 패킷이 쥐도새도 모르게 사라지거나 훼손되면 어떡해요?
  A: **그럼 그 패킷만 다시 보내라고 해!(ARQ)**

  Q: 송신 측이 패킷을 쪼갠 순서를 알아야 수신 측이 재조립할 수 있겠는데요?
  A: **그럼 순서번호를 패킷이랑 같이 보내!(SYN)**

  Q: 수신 측이 처리할 수 있는 속도보다 송신 측이 패킷을 빠르게 보내버리면 어떡하죠?
  A: **그럼 수신 측이 처리할 수 있는 양을 송신 측에 알려주고 그 만큼만 보내라고 해! (슬라이딩 윈도우)**
{% endblockquote %}

TCP의 오류 제어, 혼잡 제어, 흐름 제어 등은 그냥 글로만 보면 복잡해보이고 뭔가 외울 것도 많아보이지만, 당시 상황을 생각해보면 반드시 필요한 것들이었음을 알 수 있다.

## 헤더 구조

<center>
  {% asset_img tcp-header.png %}
  <br>
</center>

TCP는 여러 개의 필드로 나누어진 `20 bytes`, 즉 `160 bits`의 헤더를 사용하며, 각 필드의 비트를 0 또는 1로 변경하여 이 세그먼트의 정보를 나타낸다.

하지만 이 `20 bytes`라는 것이 아무 옵션도 없는 기본적인 헤더일 때의 용량이고, TCP의 옵션들을 사용하면 옵션 필드들이 추가로 붙기도 하고 기존 필드를 확장하는 경우도 있기 때문에 최대 `40 bytes`까지도 사용할 수도 있다.

위 그림에서는 한 줄이 `32 bits`를 나타내고 있는 5개의 칸으로 적층되어 있지만 실제로는 메모리가 1차원 구조이기 때문에 그냥 한 줄로 `01001001...` 처럼 주르륵 나열된 형태로 나타날 것이다.

**Source port (16 bits), Destination port (16 bits)**
이 필드들은 세그먼트의 출발지와 목적지를 나타내는 필드로, 각각 16 bits 를 할당받는다. IP 주소는 당연히 한 계층 밑인 네트워크 계층에 있는 IP의 헤더에 담기기 때문에, TCP 헤더에는 IP 주소를 나타내는 필드가 없고 포트를 나타내는 필드만 존재한다.

**Sequence Number (32 bits)**
시퀀스 번호는 전송하는 데이터의 순서를 의미하며, 32 bits를 할당받는다. `4,294,967,296` 까지의 수를 담을 수 있기 때문에 시퀀스 번호가 쉽게 중복되지는 않는다.

최초로 데이터를 전송할 때는 이 번호를 랜덤한 수로 초기화 하며, 이후 자신이 보낼 데이터의 1 bytes당 시퀀스 번호를 1씩 증가시키며 데이터의 순서를 표현하다 `4,294,967,296`를 넘어갈 경우 다시 0부터 시작한다.

**Acknowledgment Number (32 bits)**
승인 번호는 데이터를 받은 수신자가 예상하는 다음 시퀀스 번호를 의미하며, 32 bits를 할당받는다.

연결 설정과 연결 해제 때 발생하는 핸드쉐이크 과정에서는 `상대방이 보낸 시퀀스 번호 + 1`로 자신의 승인 번호를 만들어내지만, 실제로 데이터를 주고 받을 때는 `상대방이 보낸 시퀀스 번호 + 자신이 받은 데이터의 bytes`로 승인 번호를 만들어낸다.

예를 들어 1 MB짜리 데이터를 전송한다고 생각해보자. 이렇게 큰 데이터를 한번에 전송할 수는 없으므로, TCP는 이 데이터를 여러 개의 세그먼트로 쪼개서 조금씩 전송해야한다. 이때 송신자가 한번에 전송할 수 있는 데이터 양은 네트워크나 수신자의 상태에 따라 가변적이긴 하지만, 그냥 `100 bytes`라고 가정해보자.

송신자는 첫 전송으로 100 bytes 만큼만 데이터를 전송하며 시퀀스 번호를 `0`으로 보냈다. 시퀀스 번호는 1 bytes당 1씩 증가하기 때문에 첫 번째 바이트 뭉치는 0, 두 번째 바이트 뭉치는 1, 세 번째 바이트 뭉치는 2와 같은 순서로 매겨질 것이다.

즉, 이번 전송을 통해 수신자는 0~99까지 총 100개의 바이트 뭉치를 받았고, 그 다음 전송 때 받아야할 시퀀스 번호는 2가 아닌 100이 되는 것이다.

<center>
  {% asset_img ack.png %}
  <small>100 bytes 만큼 하나의 세그먼트로 묶어서 전송한다</small>
  <br>
</center>

`tcpdump`를 사용하여 패킷을 캡쳐해보면 실제로 송신 측이 보낸 데이터의 길이만큼 수신 측의 승인 번호가 증가하는 모습을 확인해 볼 수 있다.

```bash
localhost.http-alt > localhost.49680: Flags [P.], seq 160:240, ack 161, win 6374, length 80
localhost.49680 > localhost.http-alt: Flags [.], ack 240, win 6374
```

송신 측이 데이터를 보낼 때 시퀀스 번호를 `seq 160:240` 처럼 보내주면, 수신 측이 자신의 승인 번호로 콜론 뒤 쪽의 값을 사용하고 있다.

이때 시퀀스 번호의 형식은 `n 이상:m 미만`의 범위를 나타낸다. 즉, 콜론 뒤쪽의 번호는 송신 측의 시퀀스 범위에 포함되지 않으므로 수신 측이 저 번호를 그대로 가져다 쓰는 것이다.

즉, 승인 번호는 `다음에 보내줘야하는 데이터의 시작점`을 의미하는 것이다.

**Data Offset (4 bits)**
데이터 오프셋 필드에는 전체 세그먼트 중에서 헤더가 아닌 `데이터`가 시작되는 위치가 어디부터인지를 표시한다.

이 오프셋을 표기할 때는 `32비트 워드` 단위를 사용하며, 32 비트 체계에서의 `1 Word = 4 bytes`를 의미한다. 즉 이 필드의 값에 4를 곱하면 세그먼트에서 헤더를 제외한 실제 데이터의 시작 위치를 알 수 있는 것이다.

이 필드에 할당된 4 bits로 표현할 수 있는 최대 값은 `0000 ~ 1111`, 즉 `0 ~ 15 Word`이므로 기본적으로 `0 ~ 60 bytes`의 오프셋까지 표현할 수 있다. 하지만 헤더에는 필수 값들이 존재하기 때문에 최소 값은 20 bytes, 즉 `5 Word`로 고정되어 있다.

**Reserved (3 bits)**
미래를 위해 예약된 필드로, 모두 `0`으로 채워져야 한다. 상단의 헤더 그림에도 그냥 `0 0 0`으로 찍혀있는 것을 확인해볼 수 있다.

**Flags (NS ~ FIN, 9 bits)**
9개의 비트 플래그이다. 이 플래그들은 현재 세그먼트의 속성을 나타낸다. 기존에는 6개의 플래그만을 사용했지만, 혼잡 제어 기능의 향상을 위해 `Reversed` 필드를 사용하여 `NS, CWR, ECE` 플래그가 추가되었다.

| 필드 | 의미 |
|-----|-----|
| URG | `Urgent Pointer(긴급 포인터)` 필드에 값이 채워져있음을 알리는 플래그. 이 포인터가 가리키는 긴급한 데이터는 높게 처리되어 먼저 처리된다. 요즘에는 많이 사용되지 않는다. |
| ACK | `Acknowledgment(승인 번호)` 필드에 값이 채워져있음을 알리는 플래그. 이 플래그가 0이라면 승인 번호 필드 자체가 무시된다. |
| PSH | `Push` 플래그. 수신 측에게 이 데이터를 최대한 빠르게 응용프로그램에게 전달해달라는 플래그이다. 이 플래그가 0이라면 수신 측은 자신의 버퍼가 다 채워질 때까지 기다린다. 즉, 이 플래그가 1이라면 이 세그먼트 이후에 더 이상 연결된 세그먼트가 없음을 의미하기도 한다. |
| RST | `Reset` 플래그. 이미 연결이 확립되어 `ESTABLISHED` 상태인 상대방에게 연결을 강제로 리셋해달라는 요청의 의미이다. |
| SYN | `Synchronize` 플래그. 상대방과 연결을 생성할 때, 시퀀스 번호의 동기화를 맞추기 위한 세그먼트임을 의미한다. |
| FIN | `Finish` 플래그. 상대방과 연결을 종료하고 싶다는 요청인 세그먼트임을 의미한다. |

**Window Size (16 bits)**

**Checksum (16 bits)**

**Urgent Pointer (16 bits)**

**Options (32 bits)**

## TCP의 특징
보통 우리가 알고 있는 TCP의 대표적인 특징은 다음과 같다.

{% blockquote %}
- 신뢰성이 보장된다
- 연결 지향 방식이다
- 느리다
{% endblockquote %}

이 중 `신뢰성이 보장된다`라는 이야기는 TCP에서 제공하는 흐름 제어, 혼잡 제어에 대한 이야기를 해야하므로 이번 포스팅에서는 다루지 않을 예정이다. 이번에는 TCP에서 말하는 `연결`이 무엇을 의미하는지, 이 연결을 생성할 때와 해제할 때 거치는 핸드쉐이크 과정에 대해서만 이야기할 것이다.

## TCP는 연결 지향 방식이다
`연결 지향(Connection Oriented)`은 말 그대로 연결되어 있는 상태를 지향한다는 의미이다. 사실 `연결`과 `비연결`은 네트워크를 공부하다보면 여러 번 마주치게 되는 단어인데, 필자는 개인적으로 이 단어들의 의미가 조금 헷갈렸었다.

상식적으로 두 기기가 통신을 하려면 케이블이든 뭐든 연결이 되어있어야 할텐데, 굳이 왜 `연결 지향`과 `비연결 지향`을 나누어 놓은 것인지 이해가 되지 않았기 떄문이다.

이게 헷갈리는 이유는 `물리적인 연결`과 `논리적인 연결`의 차이 때문이다.

우리가 일반적으로 기기와 다른 기기를 연결했다고 할 때 떠올리는 생각은 컴퓨터와 모니터를 연결하거나, USB와 컴퓨터를 연결하는 등의 상황이다. 즉, 기기 간의 `물리적인` 연결이다.

<center>
  {% asset_img physical-connection.png 500 %}
  <small>케이블을 사용하여 두 개의 장치를 물리적으로 연결한다</small>
  <br>
</center>

반면, `연결 지향`이라는 단어에서 사용하고 있는 연결의 의미는 `논리적인 연결(Logical Connection)`을 의미한다. 이때 당연히 여러 개의 기기가 서로 통신을 하기위해서는 물리적인 연결 또한 동반되어야한다.

<center>
  {% asset_img logical-connection.png 500 %}
  <br>
</center>

조금 더 쉽게 이야기해보자면, 두 기기가 서로 `연결되어 있는 상태`를 유지하는 것이다.

전화를 예로 들자면, 전화가 전화선에 연결되어있는 것이 물리적인 연결이고 실제로 다른 전화와 통화를 하고 있는 상황이 논리적인 연결, 즉 `연결되어 있는 상태`인 것이다.

그렇다면 왜 TCP는 이런 연결 상태를 유지하는 걸까? 그 이유는 간단하다.

패킷을 여러 개로 쪼개서 보내는데, 보내는 놈이야 그냥 막 보내면 되겠지만 받는 놈 입장에서는 이 패킷이 누가 보낸거고 순서는 어떻게 되는지, 중간에 유실된 패킷은 없는지 등의 수많은 작업을 해야하기 때문이다.

그렇기 때문에 TCP는 `A와 B의 연결 상태`, `A와 C의 연결 상태` 등 각 기기간의 연결 상태를 따로 구분하고 있는 것이다. 이때 TCP는 상대방과 연결 상태를 만들거나 해제하기 위해 특별한 과정을 거치는데, 이 과정을 `핸드쉐이크(Handshake)`라고 한다.

### 3 Way Handshake
먼저, 연결을 만드는 과정부터 살펴보도록 하자. 연결을 생성할 때 거치는 핸드쉐이크 과정을 `3 Way Handshake`라고 하는데, 3 Way라는 말 그대로 총 3번의 통신 과정을 거친다.

<center>
  {% asset_img 3way-handshake.png 450 %}
  <br>
</center>

이때 클라이언트는 먼저 요청 보낸 쪽, 서버는 요청 받은 쪽이 된다는 점에 주의하자. 일반적으로 우리가 생각하는 브라우저나 모바일 앱과 서버의 고정된 역할 관계가 아니다.

그럼 한 번 각각의 상태가 어떤 것을 의미하는지, 두 기기가 서로 주고 받고 있는 `SYN`과 `ACK`는 무엇을 의미하는지 살펴보도록 하자. 필자는 이 과정을 `tcpdump`라는 유틸리티를 사용하여 캡처하였고, 실제로 핸드쉐이크를 할 때 어떤 방식으로 패킷이 출력되는지 확인해볼 수 있었다.

**CLOSED**
연결이 없는 상태이다.

**LISTEN(서버)**
서버가 연결 요청을 기다리고 있는 상태이다.

이후 클라이언트가 연결 요청을 보내기 전까지 서버는 계속 이 상태로 대기하게 된다. 즉, 적극적으로 상대방에게 대시하지 않는다는 것인데, 그래서 이 상태를 `수동 개방(Passive Open)`이라고 한다.

**SYN_SENT(클라이언트)**
클라이언트가 서버에게 연결 요청을 하면서 랜덤한 숫자인 `시퀀스 번호`를 생성해서 보낸 상태이다. 이제 이 값을 사용하여 계속 새로운 값을 만들고 서로 확인하며 클라이언트와 서버가 `연결 상태`를 확인하게 된다.

이 경우는 클라이언트는 서버에게 적극적으로 연결해달라고 조르는 상황이므로 이 상태를 `능동 개방(Active Open)`이라고 한다.

**SYN_RECV(서버)**
서버가 클라이언트에서 보낸 SYN 패킷을 제대로 받은 상태이다. 이후 서버는 제대로 된 시퀀스 번호를 받았다는 확인의 의미인 `승인 번호(Acknowledgement)` 값을 만들어서 다시 클라이언트로 돌려줘야한다. 이때 승인 번호는 처음 `클라이언트가 보낸 시퀀스 번호 + 1`이 된다.

또한 랜덤한 수로 자신의 시퀀스 번호를 다시 생성하여 함께 클라이언트로 보내준다.

**ESTABLISHED(클라이언트)**
클라이언트는 자신이 처음에 보냈던 시퀀스 번호를 알고 있기 때문에 서버가 보내준 승인 번호, 즉 `내 시퀀스 번호 + 1`을 확인할 수 있다. 자신이 보냈던 시퀀스 번호와 이번에 받은 ACK의 차가 1이라면 제대로 연결이 되었다고 판단하는 것이다.

이후 클라이언트는 연결이 성립되었다고 판단하고 `ESTABLISHED` 상태로 들어가면서, 이번에는 서버가 새롭게 만들어서 보내줬던 시퀀스 번호에 다시 1을 더하여 승인 번호로 다시 서버에게 보내준다.

**ESTABLISHED(서버)**
서버는 자신이 만들어서 보냈던 시퀀스 번호만 알고 있는 상황이다. 클라이언트와 마찬가지로 서버 또한 자신이 보냈던 시퀀스 번호와 이번에 받은 승인 번호의 차가 1이라면 제대로 연결이 되었다고 판단하고 `ESTABLISHED` 상태로 들어가게된다.

### 4 Way Handshake
연결을 생성할 때와 마찬가지로, 연결을 종료할 때도 특정한 과정을 거쳐서 연결을 종료해야한다. 이때 클라이언트와 서버가 총 4번의 통신 과정을 거치기 때문에, 이 과정을 `4 Way Handshake`라고 부른다.

<center>
  {% asset_img 4way-handshake.png 450 %}
  <br>
</center>

이때 `FIN` 패킷은 3 Way Handshake 때와 마찬가지로 시퀀스 번호를 생성해서 상대방에게 승인 번호를 받기위한 패킷이다. 이때 3 Way Handshake와 마찬가지로 클라이언트는 먼저 요청 보낸 쪽, 서버는 요청 받은 쪽이 된다는 점에 주의하자.

**FIN_WAIT_1(클라이언트)**
연결을 종료하고자 하는 클라이언트가 FIN 패킷을 서버에게 전달하면서 `FIN_WAIT1` 상태가 된다. 이 FIN 패킷에는 랜덤한 수로 `시퀀스 넘버`를 생성해서 담아보낸다.

이때 먼저 적극적으로 연결 종료 요청을 보내는 것이기 때문에 이 상태를 `능동 폐쇄(Active Close)`라고 한다.

**CLOSE_WAIT(서버)**
상대방으로부터 FIN 패킷을 받은 서버는 `클라이언트가 보낸 시퀀스 번호 + 1`로 승인 번호를 만들어서 다시 클라이언트에게 응답해주며 `CLOSE_WAIT` 상태로 들어간다. 이때 서버는 자신이 전송할 데이터가 남아있다면 이어서 계속 전송한 후, 모든 전송이 끝났다면 명시적으로 `close()`와 같은 함수를 호출하여 다음 단계로 넘어갈 것이다.

이때 서버는 상대방으로부터 연결 종료 요청을 받은 후 수동적으로 연결을 종료할 준비를 하기 때문에 이 상태를 `수동 폐쇄(Passive Close)`라고 한다.

**FIN_WAIT_2(클라이언트)**
클라이언트는 서버로부터 승인 번호를 받고 자신이 보냈던 시퀀스 번호와 승인 번호의 차가 1이 맞는지 확인한다. 하지만 아직 서버 입장에서는 데이터 전송이 끝나지 않았을 수도 있기에 `FIN_WAIT2` 상태로 들어가서 서버가 연결 종료를 허락하는 `FIN` 패킷을 보내줄 때까지 기다린다.

**LAST_ACK(서버)**
서버는 자신이 전송할 데이터가 더 이상 없다면, 연결 종료 요청에 합의한다는 의미로 클라이언트에게 `FIN` 패킷을 보낸다. 이때 서버가 보내는 FIN 패킷에 담기는 시퀀스 넘버는 클라이언트가 보낸 것을 그대로 사용하고 승인 번호는 클라이언트가 보낸 `승인 번호 + 1`을 사용한다. 이후 서버는 `LAST_ACK` 상태로 들어가며 클라이언트가 다시 승인 번호를 보내줄 때까지 대기한다.

**TIME_WAIT**
서버가 보낸 FIN 패킷을 받은 클라이언트는 다시 `서버가 보낸 시퀀스 번호 + 1`로 승인 번호를 생성하여 서버에 ACK 패킷으로 응답한다. 이후 클라이언트는 `TIME_WAIT` 상태로 들어가며, 의도하지 않은 에러로 인해 연결이 `교착 상태(Deadlock)`에 빠지는 것을 방지한다.

이 값은 `2 MSL(Maximum Segement Lifetime)`으로 정의되어 있으며, 정확한 MSL의 시간 값은 커널에 상수로 정의되어있다.

```bash
$ sysctl net.inet.tcp | grep msl
net.inet.tcp.msl: 15000
```

**CLOSED(서버)**
클라이언트가 보낸 ACK 패킷을 받은 서버는 `CLOSED` 상태로 들어가며 연결을 완전히 종료한다.

**CLOSED(클라이언트)**
`TIME_WAIT` 상태에서 일정 시간이 지나면 클라이언트도 `CLOSED` 상태로 변경된다.
