---
title: 커밋 히스토리를 이쁘게 단장하자
toc: true
widgets:
  - type: toc
    position: right
  - type: category
    position: right
sidebar:
  right:
    sticky: true
tags:
  - Git
  - Commit
  - Merge
  - Merge and squash
  - Rebase
categories:
  - Git
thumbnail:
---

이번 포스팅에서는 Github에서 제공하고 있는 3가지 브랜치 머지 전략인 `Merge`, `Squash and merge`, `Rebase and merge`의 차이에 대해서 한번 이야기해보려고 한다. 이 3가지 머지 전략 모두 브랜치를 병합한다는 목적은 같지만, 어떤 방식을 선택하냐에 따라 `커밋 히스토리`가 기록되는 방식이 달라지게 된다.

<!-- more -->

이 3가지 머지 전략은 Github 뿐만 아니라 Atlassian의 Bitbucket에서도 동일하게 지원하고 있는데, 그 만큼 머지를 할 때 커밋 히스토리를 어떤 방식으로 남길 것이냐를 선택할 수 있는 것이 중요하다고 말할 수 있다.

<center>
  {% asset_img github-merge.png 500 %}
  <small>Github에서는 Pull Request를 머지할 때 머지 전략을 선택할 수 있다.</small>
  <br>
  {% asset_img bitbucket-merge.png 500 %}
  <small>Bitbucket에서는 레파지토리 설정에서 기본 머지 전략을 선택할 수도 있다.</small>
  <br>
</center>

물론 이 머지 전략들은 각자 장단점이 있기 때문에 적재적소에 잘 사용하는 것이 중요하다. 때로는 개발팀의 전략에 따라서 기능 개발을 하는 Feature 브랜치가 Develop 브랜치로 머지될 때는 `Squash and merge`를 사용하고 Develop 브랜치가 Master 브랜치로 머지될 때는 일반적인 `Merge`를 사용하는 등 유연하게 사용하기도 한다.

하지만 적재적소에 잘 사용하려면 각각의 머지 전략이 어떤 방식으로 브랜치를 병합하는지 잘 알고있어야 가능한 법이. 그래서 이번 포스팅에서는 이 3가지 머지 방식이 뭐가 어떻게 다른지 살펴보려고 한다.

## 커밋 히스토리가 왜 중요한가요?
일단 머지 전략에 대한 설명에 들어가기에 앞서, Git의 커밋 히스토리가 왜 중요한지에 대해 먼저 설명하려고 한다. 서두에서 얘기한 3가지 머지 전략은 브랜치를 병합할 때 커밋 히스토리를 어떻게 남길 것이냐를 선택하는 것이나 마찬가지이기 때문에 `개발자들이 왜 커밋에 이렇게 목매는지`에 대한 이해가 중요하다.

`커밋(Commit)`은 Git을 구성하는 중요한 요소 중 하나이며, 하나하나의 커밋은 원칙적으로 `의미있는 하나의 변경사항`을 의미한다. 그 말인 즉슨, 커밋 메세지만 보고도 어떤 사항이 어떤 이유로 변경되었는지 쉽게 파악할 수 있어야한다는 것이다. 많은 개발자들이 의미 있는 커밋 메세지에 대한 중요성을 언급하는 이유도 짧은 커밋 메세지만 보고도 언제, 어떻게 코드가 변경되었는가를 한번에 알고 싶기 때문이다.

이 커밋들이 모여서 시간 순으로 정렬된 것을 `커밋 히스토리(Commit History)`라고 부른다. 히스토리라는 단어에서 알 수 있듯이, 이건 말 그대로 이 프로그램의 역사와 같은 것이다. 많은 개발자들이 커밋 히스토리에 `의미있는 역사`를 기록하는 것이 굉장히 중요하다고 하는 이유에는 여러가지가 있겠지만 대표적인 두 가지는 다음과 같다.

### 버그가 언제 터졌는지 파악하기가 쉽다
우리가 Git을 사용하여 프로그램의 버전 관리를 할 때 혼자 개발을 진행하는 경우도 있지만 대부분의 경우 다른 여러 명의 개발자들과 함께 협업을 하게 된다. 이때 프로그램의 변경 사항이 많을 수록, 혹은 프로그램의 규모 자체가 큰 경우 협업에 참여하고 있는 개발자들은 사소한 실수로 인해서 버그를 발생시킬 가능성 또한 커지게 된다

이때 개발자들이 커밋 히스토리를 보고 어떤 이유로 어떤 코드가 수정되었는지 빠르게 파악할 수 있다면 해당 버그의 원인을 찾는 것이 더 빨라진다.

예를 들어 새로운 버전을 릴리즈한 후에 결제 관련 버그가 터졌다고 생각해보자. 이때 당연히 개발자들은 결제에 관련된 코드부터 뜯어보기 시작할 것이다. 하지만 대부분의 프로그램은 내부적으로 수많은 모듈 간의 디펜던시가 얽혀있는 경우가 많기 때문에 그걸 짧은 시간안에 전부 파악하고 버그의 원인을 찾아서 수정한다는 것은 쉬운 일이 아니다. 이때 잘 정리된 커밋 히스토리가 있다면 이번 버전에서 결제 관련된 부분을 수정한 커밋을 찾아서 어떤 코드가 수정되었는지 빠르게 확인할 수 있다.

만약 이전 버전에서는 문제가 없었고 이번에 배포한 버전에서 문제가 발생했다면 결제 관련 버그가 발생한 이유는 해당 커밋에서 수정한 코드 때문일 가능성이 높기 때문에 조금 더 빠른 대응이 가능하다.

### 레거시 코드를 수정해야할 때
두번째 이유는 조금 슬픈 상황인데, 바로 레거시 코드를 고쳐야하는데 `코드 짠 사람이 없을 때`이다. 이 사람이 없는 이유는 퇴사라던가, 퇴사라던가, 퇴사같은 경우가 있다.

사실 레거시 코드가 무서운 이유는 코드가 너무 복잡해서 파악하기 힘들다는 것 보다는 이걸 건드렸을 때 다른 부분에 문제가 없을 것이란 보장이 없기 때문이다. 게다가 이런 코드는 어느 회사에나 다 존재하기 때문에 그렇게 드문 상황도 아니다.

만약 그 코드가 딱 봐도 책임 분리가 잘 되어 있는 코드거나 간단한 코드라면 뭐 그냥 가벼운 마음으로 수정할 수도 있지만, 대부분 우리가 수정하기 망설여지는 코드는 그냥 레거시가 아니라 `오랜 시간 숙성된 레거시`인 경우가 많다. 특히 이 코드가 회사 창립 초창기에 작성된 코드일 경우에는 그냥 코드만 봐도 당시 개발자가 얼마나 정신없이 개발을 했는지 알 수 있을 정도인 것들도 있다.

<center>
  {% asset_img exit-office.jpg 500 %}
  <small>호랭이는 죽어서 가죽을 남기고 개발자는 죽어서 레거시를 남...</small>
  <br>
</center>

이런 코드의 경우 섣불리 수정했다가 도미노처럼 와장창나는 경우가 있기 때문에 이 와장창을 몇번 경험해본 개발자들은 레거시 코드를 수정함에 있어서 신중하게 접근할 수 밖에 없다. 그럼 이때 우리가 선택할 수 있는 방법은 대략 4가지 정도다.

{% blockquote %}
  1. 건드리기 무서우니까 그냥 냅둔다.
  2. 퇴사자한테 어떻게든 연락해서 물어본다.
  3. 주변에 있는 개발자를 붙잡고 물어본다.
  4. 그냥 내가 분석한다.
{% endblockquote %}

음, 일단 1번의 경우는 아마 좋은 소리를 들을 것 같지는 않다. 일단 월급을 받고 있으니 월급 값은 해야하지 않는가?

그렇다고 이미 퇴사한 사람한테 카톡해서 코드를 작성한 의도를 물어보기에는 왠지 싸대기 맞을 것 같기도 하고 좀 그렇다. 3번 같은 경우는 그나마 나은 경우긴 하지만 다른 팀원들도 다 바쁜데 매번 붙잡고 물어볼 수도 없는 노릇이니 결국 직접 분석하는게 제일 깔끔한 방법이다.

하지만 이 분석이라는 것이 말이 쉽지, 실제로 거대한 어플리케이션에서 단 하나도 놓치지 않고 모든 의존 관계를 파악한다는 것은 사실 쉬운 일이 아니다. 게다가 이런 분석은 단순히 코드만 본다고 되는 것이 아니라 비즈니스와도 밀접한 관련이 있는 경우가 많기 때문에 해당 기능의 개발 당시 히스토리도 어느 정도 함께 파악해야한다.

그나마 팀 내에 해당 기능을 개발하게 된 히스토리를 알고 있는 동료가 있다면 다행이지만, 그 마저도 없을 경우 우리가 의지할 것은 당시 개발자가 어떤 의도로 코드를 고쳤는지 알 수 있는 `커밋 히스토리` 밖에 없는 것이다.

물론 정신없이 개발하는 와중에 커밋 메세지에 당시의 비즈니스적인 의도까지 담는 경우는 거의 없기 때문에 비즈니스 히스토리는 파악하기 힘들 수 있지만, 의미있는 단위로 커밋이 되어있다면 적어도 어떤 의도로 이 코드를 수정했는지 정도는 파악할 수 있다. 말 그대로 역사를 읽는 것이다.

## 히스토리를 깔끔하게 만드는 3가지 머지 전략

### Merge commit

### Squash and merge

### Rebase and merge

## 마치며
사실 커밋 히스토리를 잘 남기는 것은 나 자신을 위한 것일수도 있지만, 그보다는 내가 작성하는 코드를 언젠가 고쳐야할 누군가를 위해 신경써야하는 것이 더 크기는 하다.
