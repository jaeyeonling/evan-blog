---
title: 자바스크립트의 프로토타입에 대해(가제)
toc: true
widgets:
  - type: toc
    position: right
  - type: category
    position: right
sidebar:
  right:
    sticky: true
tags:
  - 프로토타입
  - 자바스크립트
  - JavaScript
  - Prototype
categories:
   - Programming
   - JavaScript
thumbnail:
---

이번 포스팅에서는 자바스크립트(JavaScript)하면 빠질 수 없는 `프로토타입(Prototype)`에 대해서 한번 이야기해보려고 한다.

필자가 처음 프론트엔드 개발을 시작했을때는 자바스크립트의 `ES5` 버전을 사용하고 있던 시절이었는데, 기존에는 자바(Java)를 주로 사용하고 있던 필자가 프론트엔드 개발로 넘어오면서 제일 애먹었던 부분이 바로 이 프로토타입이었다.

<!-- more -->

물론 지금은 자바스크립트의 위상이 많이 올라가면서 프로토타입 패턴에 대한 관심도 많아지기 시작했지만, 그래도 여전히 주류는 C 계열 언어나 Java에서 사용하는 클래스를 기반으로한 객체 생성 방식이다. 

그래서 자바스크립트를 처음 접하는 개발자에게 프로토타입을 사용한 객체 생성 방식은 낯선 방식이었고, 이로 인해 기존 개발자들이 자바스크립트로 진입하는데 어려움이 있었다. 그런 이유로 ES6에서는 `class` 예약어가 등장한 것이다.<small>(클래스로 위장한 프로토타입...)</small>

사실 필자도 아직 클래스 기반의 객체 생성 방식이 익숙하기 때문에 프로토타입에 대한 공부가 더 필요하다. 그래서 이번 포스팅에서는 프로토타입 패턴에 대해서 한번 이야기해보려고 한다.

## ES6부터 클래스를 지원하는데도 프로토타입을 굳이 알아야 하나요?
일단 ES6에서 지원하고 있는 `class` 예약어는 클래스의 탈을 쓴 프로토타입이다. 많은 개발자들이 자바스크립트의 클래스를 단순한 `문법 설탕(Syntactic Sugar)`라고 이야기하지만, 정확히 말하자면 단순한 문법 설탕은 아니다.

문법 설탕이라는 단어는 다음과 같은 뜻을 가진다.
> 해당 문법이 사라져도 그 언어가 제공하는 기능과 표현력을 동일하게 유지할 수 있다

그러나 자바스크립트의 클래스는 ES5 시절 프로토타입을 사용하여 객체를 생성했던 방법보다 더 엄격한 제약을 가지고 있기 때문에 정확히 말하자면 문법 설탕이라기보다 `상위 요소(Superset)`라고 할 수 있다.

그러면 그냥 클래스를 쓰면 되는데 왜 프로토타입을 알아야 하는 것일까?

그 이유는 아무리 자바스크립트가 `class` 예약어를 지원한다고 해도 결국 그 클래스 또한 프로토타입을 사용하여 만들기 때문이다. 결국 자바스크립트는 프로토타입 기반의 언어이다.

그리고 예전에 작성된 레거시 프론트엔드 코드의 경우에는 ES5로 작성된 것도 많기 때문에 아직까지 프론트엔드 개발자들은 ES5를 만져야하는 경우가 왕왕 있는 것이 현실이다. 물론 ES5를 ES6 이상의 버전으로 마이그레이션하려고 해도 기존의 프로토타입 기반의 객체 생성이나 상속으로 구현된 코드를 이해할 수 없다면 마이그레이션 또한 불가능하다.

## 프로토타입은 디자인 패턴이다
`프로토타입`이라고 하면 일반적으로 자바스크립트를 떠올리지만, 사실 프로토타입은 자바스크립트에서만 사용되는 것은 아니고, 그냥 일종의 디자인 패턴 중 하나이다. 그래서 `ActionScript`, `Lua`, `Perl` 등 프로토타입 기반 프로그래밍을 지원하는 다른 언어도 많다.

그래서 자바스크립트의 프로토타입을 자세히 알아보기 전에 디자인 패턴으로써의 프로토타입을 먼저 알아볼까 한다.

프로토타입 패턴은 [추상 팩토리 패턴](https://ko.wikipedia.org/wiki/%EC%B6%94%EC%83%81_%ED%8C%A9%ED%86%A0%EB%A6%AC_%ED%8C%A8%ED%84%B4)과 마찬가지로 `객체를 효율적으로 생성하는 방법`을 다루는 패턴인데, 주로 객체를 생성하는 비용이 클 때 이를 회피하기 위해 사용된다.

객체를 생성할 때의 비용이 크다는 말은 말 그대로 객체를 생성할 때마다 뭔가 일을 많이 해야한다는 뜻이다.

예를 들어 RPG 게임의 캐릭터를 하나 구현해본다고 생각해보자. 이 캐릭터는 여러가지 장비를 장착할 수 있는 기능을 가지고 있는데, 처음 캐릭터가 생성될 때 딸랑 맨 몸으로 시작하면 유저들이 싫어할 것 같으니 기본적인 장비 몇 가지를 장착한 상태로 생성될 수 있도록 만들어주려고 한다.

```java Player.java
class Weapon {}
class Armor {}
class BasicSward extends Weapon {}
class BasicArmor extends Armor {}

class Player {
    public Weapon weapon;
    public Armor armor;

    public Player() {
        this.weapon = new BasicSward(); // 초심자의 목도
        this.armor = new BasicArmor(); // 초보자용 갑주
    }
}
```

간단하게 만들어보면 대충 이런 느낌이다. `Player` 객체는 자신이 생성될 때 `BasicSward` 객체와 `BasicArmor` 객체까지 함께 생성해야한다.

이런 경우 그냥 `Player` 객체만 생성하는 상황보다는 `객체의 생성 비용이 높다`고 할 수 있다. 게다가 캐릭터 생성 시 처음 부여하는 아이템의 종류가 많아질수록 `Player`의 객체의 생성 비용 또한 계속 높아질 것이다.

음... 근데 곰곰히 생각해보니, 캐릭터가 처음 생성되며 가지고 있는 아이템이 항상 같다는 전제 조건이 있다면 생성 비용이 높은 `Player`객체를 딱 한번만 생성하고 그 다음부터는 생성된 객체를 복사해서 사용해도 될 것 같다는 생각이 든다.

```java
// 이건 너무 객체 생성 비용이 높으니까...
Player evan = new Player();
Player john = new Player();
Player wilson = new Player();

// 이런 방법으로 접근해보는 것은 어떨까?
Player player = new Player();
Player evan = player.clone();
Player john = player.clone();
Player wilson = player.clone();
```

이런 관점으로 접근하는 것이 바로 프로토타입 패턴이라고 할 수 있다. 프로토타입, 즉 `원본 객체`가 존재하고 그 객체를 복제해서 새로운 객체를 생성하는 방법인 것이다.

실제로 자바에서 프로토타입 패턴을 사용할때, 복제 대상이 되는 클래스는 보통 `Cloneable` 인터페이스를 사용하여 구현한다. Cloneable 클래스는 `clone` 메소드를 가지고 있기 때문에, 이 클래스를 상속받은 클래스는 반드시 `clone` 메소드를 오버라이딩해서 구현해야한다.

```java
class Player implements Cloneable {
  //...
  @Override
  public Player clone () throws CloneNotSupportedException {
      return (Player)super.clone();
  }
}
```

`clone` 메소드를 구현하고나면 이제 `Player` 객체는 복사 가능한 객체가 된다. 즉, 다른 객체들의 프로토타입이 될 수 있는 기능을 가지게 되었다는 것이다.

이제부터는 `Player` 객체를 추가로 생성하고 싶을 때는 기존에 생성되어 있던 객체를 그대로 복사하면 되기 때문에 높은 객체 생성 비용이 드는 것을 피할 수 있다.

```java
Player evan = new Player();
Player evanClone = evan.clone();
```

또한 `Player` 객체는 복사되어 새로운 메모리 공간을 할당받지만, 깊은 복사를 하지 않는 이상 `Player`객체가 가지고 있는 `BasicSward` 객체와 `BasicArmor` 객체는 새롭게 생성되지 않고 기존에 이 객체들이 할당된 메모리 공간을 참조하기만 한다.

즉, 메모리 공간을 아낄 수도 있다는 것이다. 자바스크립트에서 원시 자료형은 `Call by value`, 그 외 자료형은 `Call by reference`를 사용하는 것과 동일한 원리이다.

하지만 그 말인 즉슨 잠깐 정신줄 놓고 코딩하다보면 이런 상황도 발생할 수 있다는 뜻이다.

```java
Player evan = new Player();
try {
  Player evanClone = evan.clone();
  evanClone.weapon.attackPoint = 40;
  System.out.println("에반 무기 공격력 -> " + evan.weapon.attackPoint);
  System.out.println("에반 복사본 무기 공격력 -> " + evanClone.weapon.attackPoint);
}
catch (Exception e) {
    System.err.println(e);
}
```

```string
에반 무기 공격력 -> 40
에반 복사본 무기 공격력 -> 40
```

<center>
  {% asset_img overtime_work.jpg 400 %}
  <small>디버깅 지옥이 펼쳐진다...</small>
  <br>
</center>

정리해보자면 프로토타입 패턴이란, `객체를 생성할 때 원본이 되는 객체를 복사해서 생성하는 패턴`이라고 할 수 있다. 자바스크립트의 프로토타입은 이것보다는 약간 더 복잡하게 구현되어있지만 근본적인 원리 자체는 프로토타입 패턴을 따라간다.

그럼 이제 자바스크립트가 객체를 생성할 때 프로토타입 패턴을 어떤 식으로 사용하고 있는 지 한번 알아보도록 하자.

## 자바스크립트의 프로토타입
앞서 설명했듯이 프로토타입 패턴은 객체를 생성할 때 사용하는 패턴이다. 필자가 위에서 예시로 사용한 언어인 자바는 클래스 기반 프로그래밍을 지원하기 때문에, 특수한 패턴을 사용해야지만 프로토타입이라는 개념을 사용할 수 있다.

그러나 애초에 프로토타입 기반 프로그래밍을 지원하는 자바스크립트의 경우에는 애초에 모든 객체를 생성할 때 프로토타입을 사용하기 때문에, 객체를 생성하기만 해도 위에서 필자가 설명한 프로토타입 패턴이 적용된다.

그렇기 때문에 우선 자바스크립트에서 말하는 `객체(Object)`가 무엇인지, 그리고 그 객체가 생성된다는 것이 무엇을 의미하는 것인지 알아볼 필요가 있다.

### 자바스크립트가 객체를 생성하는 방법
자바스크립트에서의 `객체(Object)`는 크게 두 가지 의미를 가진다. 첫 번째는 자료형으로써의 객체, 두 번째는 모든 객체들의 원본이 되는 의미의 객체이다.<small>(사실 조금만 뜯어보면 그게 그거긴 하다)</small>

일상에서는 첫 번째 의미의 경우로 자주 사용되기는 하지만, 사실 자료형으로써 객체가 의미는 굉장히 얕은 개념이다. 자료형으로써의 객체가 가지는 의미는 일반적으로 다른 언어에서 `Map`, `ObjectArray`, `Dictionary` 등으로 불리는 `키-값(Key-Value)` 기반의 자료 구조를 말한다.

```js
const evan = {
  name: 'Evan',
  age: 29,
};
```

이런 방식을 우리는 `리터럴(Literal)`로 객체를 선언한다고 한다. 리터럴은 소스 코드의 고정된 값을 대표하는 일종의 단축어 같은 개념이기 때문에, 우리는 간단한 문법만으로 객체를 생성했다고 느끼지만 내부적으로는 객체를 생성하는 일련의 매커니즘이 작동하고 있다.

이때 다른 언어에서는 이런 자료 구조를 생성할 때 `클래스`를 사용하게된다. 예를 들어 파이썬 같은 경우, 딕셔너리를 리터럴로 선언하고 타입을 찍어보면 `dict` 클래스가 출력되는 것을 볼 수 있다.

```python
my_dict = {
    'name': 'Evan',
    'age': 29
}
type(my_dict)
```
```text
<class 'dict'>
```

우리는 `dict({ 'name': 'Evan', 'age': 29 })`와 같이 클래스를 명시적으로 사용하지않고 리터럴로 딕셔너리를 생성했지만 내부적으로는 제대로 `dict` 클래스를 사용해서 객체를 생성했다는 것이다. 

자바같은 경우는 이와 유사한 자료 구조인 `HashMap` 객체를 생성할 때 리터럴 문법을 사용하지 않기 때문에 다르다고 생각할 수 있지만, 리터럴 문법을 지원하는 `배열(Array)`을 출력해보면 결국 클래스를 기반으로 배열 객체를 생성한다는 것을 알 수 있다.

```java
String[] array = {"Evan", "29"};
System.out.println(array);
```
```text
[Ljava.lang.String;@7852e922
```

이 말인 즉슨, 다른 언어와 마찬가지로 자바스크립트의 객체도 갑자기 혼자서 뿅 하고 생성되는 것이 아니라 분명히 뭔가를 사용해서 만들어내고 있다는 말이다. 하지만 자바스크립트에는 클래스라는 개념 자체가 없는데 뭘 사용해서 객체를 만들어내고 있는 것일까?

> 답은 바로 `함수(Function)`이다.

자바스크립트에서 객체가 생성되는 원리를 조금 더 파헤쳐보기 위해서 위에서 리터럴로 선언했던 `evan` 객체를 이번에는 다른 방법으로 선언해보도록 하겠다.

```js
const evan = new Object({
  name: 'Evan',
  age: 29,
});
```

왠지 클래스 기반 언어에서 클래스를 사용하여 객체를 생성하는 것과 유사한 문법이 나타났다. 이런 방식을 `생성자(Constructor)`를 사용하여 객체를 생성한다고 한다.

클래스 기반 언어라면 `Object`는 클래스겠지만, 자바스크립트에서는 클래스가 아닌 함수이다. 즉, 자바스크립트에서의 생성자는 함수가 가지고 있다는 것이다. 저게 진짜 함수인지 알고 싶다면 브라우저 콘솔 창을 열고 `Object`를 한번 출력해보도록 하자.

```js
console.log(Object);
console.log(typeof Object);
```
```js
ƒ Object() { [native code] }
"function"
```

음, 콘솔로 찍어보니 `Object`는 확실하게 빼박캔트 함수가 맞다.

필자가 처음 자바스크립트를 사용하기 시작했을 때 받아들이기 어려웠던 부분이 바로 이 부분이었는데, 클래스 기반 프로그래밍에 익숙했던 필자에게 `new` 키워드와 생성자는 클래스만 가질 수 있는 것이었는데 갑자기 뜬금없이 함수가 나와버리니 받아들이기 힘들었던 것 같다.<small>(머리로는 알겠는데 마음이...)</small>

자, 이제 자바스크립트가 객체를 생성하는 방법을 알아보았다. 지금까지 알아본 내용을 정리해보자면 다음과 같다.

{% blockquote %}
1. 프로토타입 패턴이란 객체를 생성할 때 원본 객체를 복제하여 생성하는 방법이다.
2. 자바스크립트는 객체를 생성할 때 프로토타입 패턴을 사용한다.
3. 자바스크립트는 객체를 생성할 때 함수를 사용한다.
{% endblockquote %}

그렇다는 것은 자바스크립트가 함수를 사용하여 객체를 생성할 때 `뭔가`를 참조하고 복제해서 객체를 생성한다는 말이다. 이제부터 그 `뭔가`를 알아 볼 시간이다.

### 도대체 뭘 복제해서 객체를 만드는 걸까?
사실 디자인 패턴으로써의 프로토타입 패턴은 생각보다 그렇게 어렵지 않다. 그저 객체를 생성할 때 원본 객체를 `복제`해서 생성한다는 개념이기 때문이다.

마찬가지로 자바스크립트 또한 뭔가를 복제해서 새로운 객체를 생성하고 있다. 그럼 이제 도대체 자바스크립트가 뭘 복제해서 객체를 생성하고 있는 것인지 알아보기 위해 간단한 함수를 하나 선언해보도록 하겠다.

```js
function User () {}

const evan = new User();
console.log(evan);
```
```js
User { __proto__: Object }
```

위에서 이야기했듯이 자바스크립트는 함수를 사용하여 객체를 생성하기 때문에, 이렇게 클래스를 사용하는 것과 유사한 느낌으로 객체를 생성할 수 있다.

그렇다면 `evan` 객체는 무엇으로부터 복제된 것일까? 간단하게 생각하면 `User` 함수라고 생각해볼수 있겠지만, 사실은 `User` 함수가 복제된 것이 아니라 `User 함수의 프로토타입`을 복제한 것이다.

필자는 `User` 함수의 프로토타입을 명시적으로 선언하지 않았지만, 자바스크립트는 함수가 생성될 때 자동으로 그 함수의 `프로토타입 객체(Prototype Object)`도 함께 생성하고 해당 함수의 `prototype` 프로퍼티에 연결해둔다.

```js
function User () {}

console.log(User.prototype);
```
```js
{ constructor: f User(), __proto__: Object }
```

이 프로토타입 객체가 프로퍼티들이 뭔지 궁금할 수도 있지만 일단은 제쳐두자. 여기서 포인트는 함수를 생성하면 무조건 그 함수의 프로토타입 객체도 함께 생성된다는 것이다.

그리고 이 프로토타입 객체는 나를 사용해서 새로운 객체를 생성할 때 복제될 원본 객체를 의미한다.

즉, `new User()`라는 문법을 사용하여 새로운 객체를 만들게 되면 `User` 함수 자체가 아니라 `User` 함수가 생성될 때 함께 생성된 `User 함수의 프로토타입 객체`를 복제해서 새로운 객체를 만든다는 것이다.

<center>
  {% asset_img prototype.png 500 %}
  <small>내가 아니라 내 프로토타입을 복제하렴</small>
  <br>
</center>

이때 `User` 함수가 생성되며 함께 생성된 User 함수의 프로토타입 객체를 `Prototype Property`라고 한다.

그리고 이 프로토타입 객체를 복제해서 생성된 객체는 `__proto__` 프로퍼티에 자신이 어떤 객체를 복제해서 생성된 것인지를 알려주는 링크를 걸어놓는다. 즉, 이 프로퍼티는 해당 객체의 원본이 되는 객체로의 링크를 의미하며, 이 링크를 `Prototype Link`라고 한다.

위의 예시의 경우, `evan` 객체는 `User` 함수의 프로토타입 객체를 복제해서 생성되었기 때문에 `evan.__proto__`는 `User` 함수가 아닌 `User 함수의 프로토타입 객체`가 되는 것이다.

```js
function User () {}
const evan = new User();
console.log(User.prototype === evan.__proto__);
```
```js
true
```

### 프로토타입 체인

